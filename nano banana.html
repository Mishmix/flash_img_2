<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<title>Gemini 2.5 Flash Image — Multi Image Studio (Magic, Cancel, AR, RU→EN toggle)</title>

<!-- favicon -->
<link rel="icon" type="image/x-icon" href="D:\Portable Soft\Portable Utilitys\ЯРЛЫКИ\nano-banana.ico">

<style>
  :root{
    --bg:#090c12; --panel:#0f1520; --panel-2:#0b111a;
    --text:#ecf2f9; --muted:#90a4ba; --accent:#69b9ff; --accent-2:#39d0c7;
    --ring:#85d0ff; --danger:#ff6b6b; --ok:#34d399;
    --shadow:0 14px 52px rgba(0,0,0,.6);
    --r:18px; --gap:14px; --thin:1px;
    --sideW:clamp(14vw,16vw,18vw);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;background:var(--bg);color:var(--text);
    font:600 14px/1.5 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    overflow:hidden; letter-spacing:.1px;
  }
  a{color:var(--accent);text-decoration:none}
  a:focus-visible,button:focus-visible,select:focus-visible,textarea:focus-visible,[tabindex]:focus-visible{
    outline:2px solid var(--ring); outline-offset:2px; border-radius:.5rem;
  }
  .app{
    height:100vh; display:grid; grid-template-columns: 1fr var(--sideW); grid-template-rows:auto 1fr; gap:var(--gap);
    padding:var(--gap);
  }
  header{
    grid-column:1/-1; display:flex; align-items:center; justify-content:space-between;
    background:var(--panel); border-radius:var(--r); padding:10px 14px; box-shadow:var(--shadow)
  }
  header .left{display:flex; gap:10px; align-items:center}
  .logo{inline-size:28px; block-size:28px; border-radius:9px; background:
    radial-gradient(120% 100% at 0% 0%, #3a7bd5 0%, transparent 45%),
    linear-gradient(135deg,#3a7bd5,#3ac6d5)}
  h1{font-size:16px; margin:0 4px 0 0; letter-spacing:.2px; font-weight:700}
  .controls{display:flex; gap:10px; align-items:center}
  button, select, textarea, input[type="checkbox"]{
    background:var(--panel-2); color:var(--text); border:1px solid #1b2737; border-radius:12px; padding:8px 10px;
  }
  button{cursor:pointer; transition:.15s transform ease,.2s background ease}
  button:hover{transform:translateY(-1px)}
  main{display:grid; grid-template-rows: 1fr auto; gap:var(--gap); min-height:0}

  .stage{position:relative; background:var(--panel); border-radius:var(--r);
    display:flex; align-items:center; justify-content:center; box-shadow:var(--shadow); overflow:visible; min-height:260px;}
  .stage.has-inputs{outline:3px solid #1c3048; box-shadow:0 0 0 4px #0b141f inset, var(--shadow)}

  canvas{display:block;}
  .img-wrap{position:absolute; left:50%; top:50%; transform:translate(-50%, -50%);
    display:block; border-radius:12px; overflow:hidden; box-shadow:0 0 0 1px #1b2433; user-select:none}
  .img-wrap img{display:block; width:100%; height:100%; object-fit:contain; image-rendering:auto}

  .input-grid{position:absolute; inset:0; display:none; padding:10px; gap:10px;}
  .input-grid.show{display:grid}
  .tile{position:relative; border-radius:12px; overflow:hidden; background:#0f1318; border:1px solid #1e2633;
    transition:.18s transform ease, .18s box-shadow ease, .28s opacity ease; display:flex; align-items:center; justify-content:center}
  .tile:hover{box-shadow:0 12px 24px rgba(0,0,0,.35)}
  .tile img{width:100%; height:100%; object-fit:contain; display:block; background:linear-gradient(180deg,#0c1219,#0a1016); transition:.18s transform ease}
  .tile:hover img{transform:scale(1.02)}
  .tile .close{position:absolute; top:8px; right:8px; background:#0f151fdd; border:1px solid #22303f;
    border-radius:10px; padding:4px; line-height:0}
  .tile.active{outline:2px solid var(--accent)}
  .tile.removing{opacity:0; transform:scale(.92)}
  .grid-1{grid-template-columns:1fr; grid-template-rows:1fr}
  .grid-2{grid-template-columns:1fr 1fr; grid-template-rows:1fr}
  .grid-3{grid-template-columns:1fr 1fr; grid-template-rows:1fr 1fr}
  .grid-4{grid-template-columns:1fr 1fr; grid-template-rows:1fr 1fr}
  .tile.i0.grid-3{grid-column:1/2; grid-row:1/2}
  .tile.i1.grid-3{grid-column:2/3; grid-row:1/2}
  .tile.i2.grid-3{grid-column:1/3; grid-row:2/3}

  .top-left{position:absolute; top:10px; left:10px; z-index:3}
  .badge{background:#0f151fee; border:1px solid #223243; color:#d8e7f7;
    padding:6px 10px; border-radius:999px; font-size:12px; box-shadow:var(--shadow)}
  .hidden{display:none}

  .top-right{position:absolute; top:-14px; right:-14px; display:flex; gap:8px; z-index:3}
  .icon-btn{background:#0f151fdd; border:1px solid #22303f; border-radius:12px; padding:6px; display:inline-flex; align-items:center; justify-content:center}

  .loader{position:absolute; inset:0; display:none; place-items:center; background:rgba(7,10,14,.55); backdrop-filter:blur(3px); z-index:5;}
  .loader.show{display:grid}
  .spinner{ inline-size:46px; block-size:46px; border-radius:50%; border:4px solid #223142; border-top-color:var(--accent); animation:spin 1s linear infinite; }
  @keyframes spin{ to{ transform:rotate(360deg) } }
  .loader .cancel-area{margin-top:10px; display:flex; gap:8px; align-items:center; justify-content:center;}
  .cancel-btn{background:#0f151f; border:1px solid #2b3d53; color:#eaf2ff; padding:8px 12px; border-radius:10px; cursor:pointer}

  .toast{position:fixed; bottom:20px; left:50%; translate:-50% 0; background:#0f151fee; color:#fff;
    border:1px solid #22303f; padding:10px 12px; border-radius:12px; box-shadow:var(--shadow); display:none; z-index:100;
    font-size:14px; font-weight:700; letter-spacing:.2px; transform-origin:50% 100%; opacity:0; transform:translate(-50%,10px) scale(.98);
    transition:opacity .25s ease, transform .25s ease;}
  .toast.show{display:block; opacity:1; transform:translate(-50%,0) scale(1)}

  .dropzone{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:auto;
    border:2px dashed #243140; color:#90a4ba; border-radius:var(--r); margin:10px; padding:10px; text-align:center}
  .dropzone.hide{display:none}
  .dz-inner{opacity:.95}
  .paste-hint{font-size:12px; opacity:.85; margin-top:6px}

  .carousel-nav{position:absolute; inset-block:0; inset-inline:0; display:none; pointer-events:none}
  .carousel-nav.active{display:block}
  .nav-btn{position:absolute; top:50%; translate:0 -50%; background:#0f151fdd; border:1px solid #22303f; pointer-events:auto}
  .nav-btn.left{left:10px} .nav-btn.right{right:10px}

  .prompt-panel{background:var(--panel); border-radius:var(--r); padding:10px; box-shadow:var(--shadow);
    opacity:1; transform:none; pointer-events:auto; transition:.24s ease;}
  .prompt-row{display:grid; grid-template-columns:auto 1fr auto; gap:10px; align-items:center}
  textarea{resize:vertical; min-height:56px; max-height:40vh; background:var(--panel-2); border:1px solid #1b2737; border-radius:12px; padding:10px 12px; font-weight:600;}
  .tool-btn{display:inline-flex; align-items:center; justify-content:center; padding:10px; border-radius:12px; background:var(--panel-2); border:1px solid #1b2737}
  .send-group{display:flex; gap:8px; align-items:center}
  .mini-sel{width:64px; text-align:center; font-weight:700}
  .tool-btn.toggle.active{background:var(--accent-2); color:#0b111a}
  .preset-sel{max-width:160px}
  .ar-sel{min-width:92px}

  aside{background:var(--panel); border-radius:var(--r); padding:10px; box-shadow:var(--shadow); overflow:auto; max-height:calc(100vh - 2*var(--gap) - 64px);} 
  .aside-head{display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:6px}
  .details{border:1px solid #1e2633; border-radius:12px; padding:8px; margin-bottom:10px; background:linear-gradient(180deg,#0f151f 0%, #0d141c 100%);} 
  .d-row{display:grid; grid-template-columns:1fr; gap:6px}
  .d-meta{font-size:12px; color:#90a4ba}
  .d-prompt{width:100%; background:var(--panel-2); border:1px solid #1b2737; border-radius:10px; padding:8px; font-size:13px}
  .hist-card{border:1px solid #1e2633; border-radius:12px; padding:8px; background:linear-gradient(180deg,#0f151f 0%, #0d141c 100%); display:flex; flex-direction:column; gap:8px; margin-bottom:8px;}
  .hist-top{display:flex; align-items:center; justify-content:space-between; gap:8px}
  .hist-meta{font-size:12px; color:#90a4ba}
  .hist-actions{display:flex; gap:8px}
  .dl-btn{padding:6px; border-radius:10px; border:1px solid #1b2737; background:#0f151f}
  .thumbs-row{display:flex; gap:6px; overflow-x:auto}
  .thumb-it{position:relative; inline-size:56px; block-size:56px; border-radius:8px; overflow:hidden; flex:0 0 auto; background:#0f1318; border:1px solid #1e2633; cursor:grab}
  .thumb-it img{width:100%; height:100%; object-fit:cover}
  .thumb-dl{position:absolute; right:2px; bottom:2px; background:#0f151fbb; border:1px solid #1b2737; border-radius:8px; padding:2px}

  /* Modals (Magic + Presets share the same styling) */
  .modal{position:fixed; inset:0; display:none; place-items:center; z-index:200; background:rgba(7,10,14,.6); backdrop-filter:blur(2px)}
  .modal.show{display:grid}
  .modal-card{width:min(860px,94vw); max-height:84vh; overflow:auto; background:#0f1520; border:1px solid #22303f; border-radius:16px; box-shadow:var(--shadow); padding:14px}
  .modal-head{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px}
  .modal-title{font-weight:800}
  .modal-list{display:grid; gap:8px; margin:8px 0}
  .opt{display:flex; gap:10px; align-items:flex-start; background:#0b111a; border:1px solid #1b2737; border-radius:12px; padding:10px; transition:.2s background}
  .opt:hover{background:#101823}
  .opt input{margin-top:4px}
  .opt pre{white-space:pre-wrap; margin:0; font:600 13px/1.45 ui-sans-serif, system-ui}
  .modal-actions{display:flex; justify-content:flex-end; gap:8px; margin-top:10px}
  .btn{background:#0f151f; border:1px solid #22303f; padding:8px 12px; border-radius:10px; color:#eaf2ff; cursor:pointer}
  .btn.primary{background:linear-gradient(180deg,#1a2a3d,#162233); border-color:#2b3d53}
  .btn:disabled{opacity:.6; cursor:not-allowed}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .grow{flex:1 1 auto}
  .small{font-size:12px; opacity:.85}
  ::-webkit-scrollbar{width:10px;height:10px} ::-webkit-scrollbar-thumb{background:#203040;border-radius:8px}

  #magicBtn[data-busy="1"]{opacity:.65; pointer-events:none}
  #sendBtn[data-busy="1"]{opacity:.6; pointer-events:none}
  #processPhotoBtn[data-busy="1"]{opacity:.6; pointer-events:none}
  #openPresetsBtn[data-busy="1"]{opacity:.6; pointer-events:none}


/* Cropper styles */
/* Styles for the cropping interface and handles. */

/* Style for crop handles: small circles that can be dragged to resize the selection */
#cropModal .cr-h {
  position: absolute;
  width: 12px;
  height: 12px;
  background: #69b9ff;
  border: 2px solid #0f151f;
  border-radius: 50%;
  z-index: 5;
}

/* Position each handle using CSS variables set by JS */
#cropModal .cr-nw { left: calc(var(--x, 10px) - 6px); top: calc(var(--y, 10px) - 6px); cursor: nwse-resize; }
#cropModal .cr-n  { left: calc(var(--xMid, 10px) - 6px); top: calc(var(--y, 10px) - 6px); cursor: ns-resize; }
#cropModal .cr-ne { left: calc(var(--x2, 10px) - 6px); top: calc(var(--y, 10px) - 6px); cursor: nesw-resize; }
#cropModal .cr-e  { left: calc(var(--x2, 10px) - 6px); top: calc(var(--yMid, 10px) - 6px); cursor: ew-resize; }
#cropModal .cr-se { left: calc(var(--x2, 10px) - 6px); top: calc(var(--y2, 10px) - 6px); cursor: nwse-resize; }
#cropModal .cr-s  { left: calc(var(--xMid, 10px) - 6px); top: calc(var(--y2, 10px) - 6px); cursor: ns-resize; }
#cropModal .cr-sw { left: calc(var(--x, 10px) - 6px); top: calc(var(--y2, 10px) - 6px); cursor: nesw-resize; }
#cropModal .cr-w  { left: calc(var(--x, 10px) - 6px); top: calc(var(--yMid, 10px) - 6px); cursor: ew-resize; }

/* Dotted outline for the selection overlay */
#cropOverlay:after {
  content: "";
  position: absolute;
  inset: 0;
  border: 1px dashed rgba(201,235,255,.55);
  border-radius: 8px;
  pointer-events: none;
}

/* Style for crop-open button (added to top-left of stage) */
#cropOpenBtn {
  background: #0f151fdd;
  border: 1px solid #22303f;
  color: #eaf2ff;
  padding: 6px 10px;
  border-radius: 10px;
  font-weight: 700;
}
#cropOpenBtn[disabled] {
  opacity: .55;
  cursor: not-allowed;
}
</style>
</head>
<body>
<div class="app" role="application" aria-label="Gemini 2.5 Flash Image Studio">
  <header>
    <div class="left">
      <div class="logo" aria-hidden="true"></div>
      <h1>Image Flash Studio</h1>
    </div>
    <div class="controls hidden">
      <button id="resetBtn" aria-label="Очистить сцену">Очистить</button>
    </div>
  </header>

  <main role="main" aria-live="polite">
    <section class="stage" id="stage" aria-label="Холст/галерея">
      <canvas id="canvas" aria-label="Canvas"></canvas>
      <a id="imgLink" class="img-wrap" download="variant.png" style="display:none"><img id="imgView" alt="Результат" draggable="true"></a>
      <div id="inputGrid" class="input-grid"></div>
      <div class="top-left">
        <span class="badge hidden" id="variantBadge"></span>
      </div>
      <div class="loader" id="loader">
        <div style="display:flex; flex-direction:column; align-items:center; gap:8px;">
          <div class="spinner" aria-label="Загрузка"></div>
          <div id="progressText" style="font-size:12px; color:#cfe6ff;">Готово 0/0</div>
          <div class="cancel-area">
            <button id="cancelBtn" class="cancel-btn" aria-label="Отменить генерацию">Отменить</button>
          </div>
        </div>
      </div>
      <div class="top-right">
        <button class="icon-btn" id="toggleViewBtn" aria-label="Свернуть/показать результат" title="Свернуть/показать результат">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M12 3l9 5-9 5-9-5 9-5Zm-7 9l7 4 7-4M5 16l7 4 7-4" stroke="#cfe6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </button>
        <button class="icon-btn" id="closeBtn" aria-label="Очистить сцену">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M6 6l12 12M18 6L6 18" stroke="#cfe6ff" stroke-width="2" stroke-linecap="round"/></svg>
        </button>
      </div>
      <div class="dropzone" id="dz" aria-label="Зона загрузки" aria-dropeffect="copy">
        <div class="dz-inner">
          <div><strong>Перетащи изображения (до 4)</strong> сюда<br/>или нажми для выбора файлов</div>
          <div class="paste-hint">Работает и <span class="kbd">Ctrl/⌘+V</span></div>
          <input id="fileInput" class="hidden" type="file" accept="image/*" multiple />
        </div>
      </div>
      <div class="carousel-nav" id="carouselNav" aria-hidden="true" aria-label="Навигация по вариантам">
        <button class="nav-btn left" id="prevBtn" aria-label="Предыдущий (←)">←</button>
        <button class="nav-btn right" id="nextBtn" aria-label="Следующий (→)">→</button>
      </div>
    </section>

    <section class="prompt-panel" id="promptPanel" aria-label="Панель промта">
      <div class="prompt-row">
        <button id="openPickerBtn" class="tool-btn" title="Загрузить изображения" aria-label="Загрузить изображения">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M12 3v12m0 0l-4-4m4 4l4-4M5 21h14" stroke="#cfe6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </button>
        <textarea id="prompt" placeholder="Промт (RU/EN)." aria-label="Промт"></textarea>
        <div class="send-group">
          <button id="magicBtn" class="tool-btn" title="Magic — улучшить черновик" aria-label="Magic">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M5 15l9-9m-7 7l4 4M3 21l3-3m9-13l3-3M14 7l3 3" stroke="#cfe6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </button>

          <button id="translateBtn" class="tool-btn toggle" title="Переводить перед отправкой" aria-label="Перевод">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M3 5h18M10 5c0 4 4 8 8 8m-8 0l-2 4m2-4h5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </button>

          <select id="arSelect" class="mini-sel ar-sel hidden" aria-label="Aspect Ratio" title="Соотношение сторон (только без исходников)">
            <option value="1:1">1:1</option>
            <option value="16:9">16:9</option>
            <option value="9:16">9:16</option>
            <option value="4:5">4:5</option>
            <option value="5:4">5:4</option>
            <option value="3:2">3:2</option>
            <option value="2:3">2:3</option>
            <option value="4:3">4:3</option>
            <option value="3:4">3:4</option>
            <option value="21:9">21:9</option>
            <option value="9:21">9:21</option>
          </select>

          <button id="perImageBtn" class="tool-btn toggle hidden" title="Персональные промты для каждого изображения" aria-label="Персональные промты">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M4 8l8-4 8 4-8 4-8-4Zm0 6l8 4 8-4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </button>
          <select id="varCount" class="mini-sel" aria-label="Количество вариантов">
            <option>1</option><option>2</option><option>3</option><option>4</option><option>5</option>
            <option>6</option><option>7</option><option>8</option><option>9</option><option>10</option>
          </select>
          <button id="sendBtn" class="tool-btn" title="Отправить" aria-label="Отправить">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M4 4l16 8-16 8 4-8-4-8zM8 12h8" stroke="#cfe6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </button>

          <!-- Обработать фото -->
          <button id="processPhotoBtn" class="tool-btn" title="Обработать фото" aria-label="Обработать фото">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M4 7h4l2-2h4l2 2h4v10H4V7Z" stroke="#cfe6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <circle cx="12" cy="12" r="3.5" stroke="#cfe6ff" stroke-width="2"/>
            </svg>
          </button>

          <!-- ПРЕСЕТЫ -->
          <select id="presetQuick" class="mini-sel preset-sel hidden" title="Быстрые пресеты"></select>
          <button id="openPresetsBtn" class="tool-btn" title="Пресеты" aria-label="Пресеты">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M4 6h16M4 12h16M4 18h10" stroke="#cfe6ff" stroke-width="2" stroke-linecap="round"/>
            </svg>
          </button>
        </div>
      </div>
    </section>
  </main>

  <aside aria-label="Детали и история" role="complementary">
    <div class="details">
      <div class="d-row">
        <div class="d-meta" id="activeMeta">Нет активного изображения</div>
        <textarea id="activePerPrompt" class="d-prompt hidden" placeholder="Персональный промт для активного изображения (RU/EN)"></textarea>
      </div>
    </div>

    <div class="aside-head">
      <div class="tiny">История (до 10):</div>
      <button id="clearHistBtn" class="tiny">Очистить историю</button>
    </div>
    <div id="history" class="scroll" role="list"></div>
  </aside>
</div>

<!-- Magic modal -->
<div id="magicModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="magicTitle" aria-describedby="magicDesc">
  <div class="modal-card">
    <div class="modal-head">
      <div class="modal-title" id="magicTitle">Хотите заменить текущий черновик на улучшенный?</div>
      <div id="magicDesc" class="tiny" style="opacity:.8">Выбери вариант ниже</div>
    </div>
    <div id="magicList" class="modal-list"></div>
    <div class="modal-actions">
      <button id="magicCancel" class="btn">Нет</button>
      <button id="magicApply" class="btn primary">Да</button>
    </div>
  </div>
</div>

<!-- Presets modal -->
<div id="presetsModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="presetsTitle" aria-describedby="presetsDesc">
  <div class="modal-card">
    <div class="modal-head">
      <div class="modal-title" id="presetsTitle">Заготовленные промты</div>
      <div id="presetsDesc" class="small">Файл: <span id="stylesPathHint">не выбран</span></div>
    </div>

    <div class="row" style="margin-bottom:8px;">
      <button id="linkStylesBtn" class="btn">Выбрать styles.json</button>
      <button id="presetRefreshBtn" class="btn">Обновить список</button>
      <div class="small" id="fsSupportHint"></div>
      <div class="grow"></div>
      <button id="presetInsertBtn" class="btn primary" title="Вставить выбранные пресеты в поле промта">Вставить выбранные</button>
    </div>

    <div class="opt">
      <div class="grow">
        <div class="row" style="margin-bottom:6px;">
          <input id="presetNameInput" class="grow" placeholder="Название пресета (например: 'Футболка → Поло')" />
          <button id="presetSaveBtn" class="btn primary">Сохранить в styles.json</button>
        </div>
        <textarea id="presetTextInput" class="d-prompt" placeholder="Текст промта (любая строка/JSON)"></textarea>
        <div class="small" style="margin-top:6px;">После сохранения список обновится автоматически.</div>
      </div>
    </div>

    <div style="margin-top:10px; display:flex; align-items:center; gap:8px;">
      <div class="modal-title" style="font-size:14px;">Список пресетов</div>
      <button id="presetSelectAll" class="btn">Выбрать все</button>
      <button id="presetSelectNone" class="btn">Снять все</button>
    </div>
    <div id="presetList" class="modal-list" style="margin-top:6px;"></div>

    <div class="modal-actions">
      <button id="presetsCloseBtn" class="btn">Закрыть</button>
    </div>
  </div>
</div>

<!-- Окно кадрирования -->
  <div id="cropModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="cropTitle" aria-describedby="cropDesc" style="display:none">
    <div class="modal-card" style="max-width:960px">
      <div class="modal-head">
        <div class="modal-title" id="cropTitle">Кадрирование</div>
        <div id="cropDesc" class="small" style="opacity:.85">Перетащи или потяни за углы/грани. Колёсико — масштаб холста. Enter — применить, Esc — отмена.</div>
      </div>
      <div style="position:relative; background:#0b111a; border:1px solid #1b2737; border-radius:12px; overflow:hidden; aspect-ratio:16/9; max-height:70vh;">
        <canvas id="cropCanvas" style="display:block; width:100%; height:100%;"></canvas>
        <div id="cropOverlay" aria-label="Область обрезки" style="position:absolute; inset:auto; border:2px solid #69b9ff; box-shadow:0 0 0 200vmax rgba(0,0,0,.45); border-radius:8px; cursor:move;"></div>
        <div class="cr-h cr-nw" data-dir="nw"></div>
        <div class="cr-h cr-n"  data-dir="n"></div>
        <div class="cr-h cr-ne" data-dir="ne"></div>
        <div class="cr-h cr-e"  data-dir="e"></div>
        <div class="cr-h cr-se" data-dir="se"></div>
        <div class="cr-h cr-s"  data-dir="s"></div>
        <div class="cr-h cr-sw" data-dir="sw"></div>
        <div class="cr-h cr-w"  data-dir="w"></div>
      </div>
      <div class="modal-actions" style="margin-top:10px">
        <div class="row" style="gap:10px; align-items:center;">
          <label class="switch inline" title="Фиксировать соотношение сторон">
            <span>Фикс. AR</span>
            <input id="cropLockAR" type="checkbox" />
          </label>
          <select id="cropAR" class="mini-sel ar-sel" title="Соотношение сторон">
            <option value="free">Свободно</option>
            <option value="1:1">1:1</option>
            <option value="4:5">4:5</option>
            <option value="3:2">3:2</option>
            <option value="16:9">16:9</option>
            <option value="9:16">9:16</option>
          </select>
          <div class="grow"></div>
          <button id="cropCancel" class="btn">Отмена (Esc)</button>
          <button id="cropApply"  class="btn primary">Применить (Enter)</button>
        </div>
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite">Генерация…</div>

<script>
/* ==== Константы API / модели ==== */
const API_KEY = 'AIzaSyABLuooMLBZO4CdKoZcuKduSIGIFBjBQFU';
const MODEL_ID = 'gemini-2.5-flash-image-preview';
const ENDPOINT = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_ID}:generateContent`;
const MAX_HISTORY = 10;
const MAX_INPUTS = 4;

/* ==== Элементы ==== */
const els = {
  stage: document.getElementById('stage'),
  canvas: document.getElementById('canvas'),
  imgWrap: document.getElementById('imgLink'),
  imgView: document.getElementById('imgView'),
  inputGrid: document.getElementById('inputGrid'),
  dz: document.getElementById('dz'),
  fileInput: document.getElementById('fileInput'),
  openPickerBtn: document.getElementById('openPickerBtn'),
  promptPanel: document.getElementById('promptPanel'),
  prompt: document.getElementById('prompt'),
  translateBtn: document.getElementById('translateBtn'),
  arSelect: document.getElementById('arSelect'),
  perImageBtn: document.getElementById('perImageBtn'),
  sendBtn: document.getElementById('sendBtn'),
  varCount: document.getElementById('varCount'),
  magicBtn: document.getElementById('magicBtn'),
  closeBtn: document.getElementById('closeBtn'),
  resetBtn: document.getElementById('resetBtn'),
  prevBtn: document.getElementById('prevBtn'),
  nextBtn: document.getElementById('nextBtn'),
  carouselNav: document.getElementById('carouselNav'),
  history: document.getElementById('history'),
  clearHistBtn: document.getElementById('clearHistBtn'),
  loader: document.getElementById('loader'),
  progressText: document.getElementById('progressText'),
  cancelBtn: document.getElementById('cancelBtn'),
  toast: document.getElementById('toast'),
  variantBadge: document.getElementById('variantBadge'),
  activeMeta: document.getElementById('activeMeta'),
  activePerPrompt: document.getElementById('activePerPrompt'),
  toggleViewBtn: document.getElementById('toggleViewBtn'),
  magicModal: document.getElementById('magicModal'),
  magicList: document.getElementById('magicList'),
  magicCancel: document.getElementById('magicCancel'),
  magicApply: document.getElementById('magicApply'),
  processPhotoBtn: document.getElementById('processPhotoBtn'),

  // PRESETS UI
  openPresetsBtn: document.getElementById('openPresetsBtn'),
  presetQuick: document.getElementById('presetQuick'),
  presetsModal: document.getElementById('presetsModal'),
  linkStylesBtn: document.getElementById('linkStylesBtn'),
  presetRefreshBtn: document.getElementById('presetRefreshBtn'),
  presetInsertBtn: document.getElementById('presetInsertBtn'),
  presetSaveBtn: document.getElementById('presetSaveBtn'),
  presetNameInput: document.getElementById('presetNameInput'),
  presetTextInput: document.getElementById('presetTextInput'),
  presetList: document.getElementById('presetList'),
  presetSelectAll: document.getElementById('presetSelectAll'),
  presetSelectNone: document.getElementById('presetSelectNone'),
  presetsCloseBtn: document.getElementById('presetsCloseBtn'),
  stylesPathHint: document.getElementById('stylesPathHint'),
  fsSupportHint: document.getElementById('fsSupportHint'),
};

/* ==== Состояние ==== */
let state = {
  inputs: [],
  activeId: null,
  outputs: [], currentIdx: 0,
  showResults: false,
  history: loadHistory(),
  generating: false,
  genToken: 0,
  cancelled: false,
  magic: { variants: [], selectedIdx: 0, open: false, busy: false },
  translateEnabled: true,
  perImage: false,
  presets: [],
  pureAR: 1, // AR для чистой генерации
};

/* ==== Персист ключи ==== */
const TR_TOGGLE_KEY = 'nb_translate_enabled_v1';

/* ==== PRESET PROMPTS (в точности как дал заказчик) ==== */
const PRESET_PROMPT_1 = `{
  "subject": {
    "type": "portrait",
    "constraints": {
      "pose": "do_not_change",
      "framing": "do_not_change",
      "proportions": "do_not_change",
      "expression": "do_not_change",
      "body_position": "do_not_change",
      "angle": "do_not_change",
      "perspective": "do_not_change"
    }
  },
  "environment": {
    "integration_mode": "overlay_around_original",
    "description": "Surround the existing portrait with a studio-like environment without moving or reposing the subject.",
    "background": {
      "style": "seamless",
      "color": "neutral_gray",
      "gradient": "smooth"
    },
    "lighting_equipment": {
      "required": true,
      "visible": true,
      "types": ["softbox", "reflector"],
      "placement": ["front", "slightly_left", "slightly_right"],
      "integration": "add_to_current_scene"
    }
  },
  "lighting": {
    "mode": "studio_soft_frontal",
    "uniformity": "even",
    "shadows": "none_under_eyes",
    "white_balance": "daylight_D65",
    "direction": "frontal",
    "color_casts": "remove_all",
    "integration": "override_original_light"
  },
  "skin": {
    "tone": {
      "normalized": true,
      "evened_out": true,
      "matched_to_environment": true,
      "natural": true,
      "realistic": true
    },
    "imperfections": "no_blotches_no_residual_casts"
  },
  "restrictions": {
    "identity": "preserve",
    "pose": "preserve_exactly",
    "framing": "preserve_exactly",
    "expression": "preserve_exactly"
  },
  "output": {
    "style": "professional_studio_effect_applied_to_original",
    "focus": "subject_face",
    "changes": ["lighting", "skin_tone", "environment_only"]
  }
}
`;

const PRESET_PROMPT_2 = `{
  "subject": {
    "type": "portrait",
    "constraints": {
      "pose": "do_not_change",
      "framing": "do_not_change",
      "proportions": "do_not_change",
      "expression": "do_not_change",
      "body_position": "do_not_change",
      "angle": "do_not_change",
      "perspective": "do_not_change"
    }
  },
  "environment": {
    "integration_mode": "overlay_around_original",
    "description": "Surround the existing portrait with a studio-like environment without moving or reposing the subject.",
    "background": {
      "style": "seamless",
      "color": "neutral_gray",
      "gradient": "smooth"
    },
    "lighting_equipment": {
      "required": true,
      "visible": true,
      "types": ["softbox", "reflector"],
      "placement": ["front", "slightly_left", "slightly_right"],
      "integration": "add_to_current_scene"
    }
  },
  "lighting": {
    "mode": "studio_soft_frontal",
    "uniformity": "even",
    "shadows": "none_under_eyes",
    "white_balance": "daylight_D65",
    "direction": "frontal",
    "color_casts": "remove_all",
    "integration": "override_original_light"
  },
  "skin": {
    "tone": {
      "normalized": true,
      "evened_out": true,
      "matched_to_environment": true,
      "natural": true,
      "realistic": true
    },
    "imperfections": "no_blotches_no_residual_casts"
  },
  "colorization": {
    "enabled": true,
    "mode": "restore_from_grayscale",
    "result": "accurate_lifelike_colors",
    "skin": "ideal_natural_tone",
    "eyes": "clear_natural",
    "teeth": "slightly_brightened"
  },
  "restrictions": {
    "identity": "preserve",
    "pose": "preserve_exactly",
    "framing": "preserve_exactly",
    "expression": "preserve_exactly"
  },
  "output": {
    "style": "professional_studio_effect_applied_to_original",
    "focus": "subject_face",
    "changes": ["lighting", "skin_tone", "environment_only", "colorization"]
  }
}
`;

/* ==== Magic промт (оставлен без изменений по логике) ==== */
const MAGIC_ENHANCER_PROMPT = `ТЫ — эксперт по промт-инжинирингу для Gemini 2.5 Flash Image.
Твоя задача: на основе пользовательского черновика определить тип задачи (Single image или Multi-image), затем подобрать подходящий шаблон (см. ниже).

🔹 Если шаблон подходит — разверни его в улучшенный промт, добавь детализацию: стиль, свет, композицию, настроение.
🔹 Если шаблона нет — сгенерируй новый промт самостоятельно в том же формате (максимально точное, детализированное и логичное описание).

Выход всегда должен быть в виде одного улучшеного промта

🖼️ Single image editing

Universal Templates
0.1 Change {{object}} to {{new_state}}, keep {{preserve}} unchanged
0.2 Transform to {{style}}, while maintaining {{composition/subject}}
0.3 Replace "{{old_text}}" with "{{new_text}}", keep font style

Basic Edits (Color/Light)
1.1 Change the {{object}} color to {{color}}, preserve lighting & texture
1.2 Switch scene to {{time_of_day}} lighting, same camera angle
1.3 Increase contrast by {{percentage}}, keep palette intact

Object Replacement/Addition
2.1 Remove {{object}}, fill background seamlessly
2.2 Add a {{object}} on the {{location}}, match existing light
2.3 Replace {{object1}} with {{object2}}, preserve scale & perspective

Background & Environment
3.1 Change background to {{new_bg}}, keep subject position
3.2 Extend canvas {{percentage}}% left/right, continue background detail
3.3 Blur background slightly for depth-of-field

Style & Medium Transfer
4.1 Convert to {{art_movement}} style with {{key_traits}}, keep composition
4.2 Render as {{medium}} illustration, maintain colors
4.3 Apply high-contrast noir film aesthetic, subject unchanged

Consistent Characters
5.1 Give {{character}} a {{new_outfit}}, keep face & pose
5.2 Change hairstyle to {{style}}, same expression
5.3 Place {{character}} in {{new_setting}}, exact scale/angle

Product & Commercial
6.1 Photorealistic shot of {{product}} on white backdrop, soft shadow
6.2 Add glossy reflection under {{product}}, #FFFFFF background
6.3 Flat-lay {{product}} with minimal props, top-down view

Portraits & Fashion
7.1 Cinematic portrait of {{subject}}, 85 mm lens, bokeh, rim light
7.2 Editorial fashion full-body, studio grey, softbox lighting
7.3 Street-style photo at golden hour, shallow DOF

Fantasy & Characters
8.1 Epic fantasy hero in {{armor_style}}, dramatic backlight
8.2 Dark sorcerer casting blue flames, gothic ruins
8.3 Cute chibi dragon, pastel palette, kawaii style

Landscapes & Nature
9.1 Wide-angle {{landscape}}, sunrise, volumetric fog
9.2 Realistic alpine lake, autumn colors, polarizing filter
9.3 Sci-fi desert planet with twin moons, crisp shadows

Architecture & Interior
10.1 Modern minimalist living room, natural light, neutral tones
10.2 Brutalist concrete façade, overcast sky, 35 mm grain
10.3 Isometric smart-home cutaway, labeled rooms

Illustration & Infographics
11.1 Flat vector infographic: {{topic}}, bold icons, pastel palette
11.2 Hand-drawn explainer diagram, black ink, off-white paper
11.3 Isotype pictogram sequence, minimal text

Anime & Manga
12.1 Anime close-up, expressive eyes, cel-shade
12.2 Manga panel, dynamic angle, speed lines
12.3 Chibi mascot waving, high-key colors

Game Assets (Isometric)
13.1 Isometric medieval house sprite, 512 px
13.2 Top-down RPG forest tile, seamless
13.3 Icon {{item}}, 64×64 px, crisp outline

Pixel Art
14.1 8-bit character idle, NES palette
14.2 Retro arcade start screen, neon text
14.3 Pixel parallax city skyline, night

Graffiti & Street Art
15.1 Spray-paint mural of {{subject}}, bold gradients, drips
15.2 Stencil silhouette on concrete, high contrast
15.3 Three-color throw-up tag “{{word}}”

Cyberpunk & Futurism
16.1 Neon-lit alley, rain-soaked pavement, holographic ads
16.2 AR HUD overlay on cityscape, high-tech
16.3 Android hacker portrait, chromatic aberration

Historical Illustration
17.1 Victorian engraving of {{event}}, cross-hatching
17.2 Ancient Roman mosaic {{subject}}, tesserae detail
17.3 Medieval illuminated initial, gold leaf

Minimalism & Flat Design
18.1 Ultra-minimal product hero on monochrome
18.2 Flat-lay desk items, two-color palette
18.3 One-line continuous drawing of {{subject}}

Logos & Icons
19.1 Monoline logo {{brand}}, balanced proportions
19.2 Glyph icon set {{theme}}, consistent stroke
19.3 Abstract geometric mark for {{concept}}

Abstraction & Patterns
20.1 Generative swirl pattern, complementary colors
20.2 Low-poly crystal cluster, pastel gradient
20.3 Fluid ink marbling, hi-res

Storyboard & Keyframes
21.1 Storyboard frame #1: {{scene}}, 4:3, rough pencil
21.2 Keyshot dynamic action pose, motion blur
21.3 Concept sheet: orthographic views, neutral grey

UI & Web Design
22.1 Clean SaaS dashboard mock-up, glassmorphism, 
22.1 Clean SaaS dashboard mock-up, glassmorphism, 
22.2 Mobile login screen, dark mode, centered form
22.3 Landing hero: bold headline left, illustration right

Meme & Overlay
23.1 Top text "{{text1}}", bottom "{{text2}}", Impact font
23.2 Replace signboard text with "{{new_text}}", same perspective
23.3 Insert watermark "{{handle}}" bottom-right

Multi-image & Collage
24.1 Merge image A & B, seamless mid-blend
24.2 Double-exposure portrait + cityscape, preserve silhouette
24.3 Collage with torn-paper edges, handmade vibe
🖼️➕🖼️ Multi-image editing

Create a new image by combining the elements from the provided images. Take the [element from image 1] and place it with/on the [element from image 2]. The final image should be a [description of the final scene].

Using the provided images, place [element from image 2] onto [element from image 1]. Ensure that the features of [element from image 1] remain completely unchanged. The added element should [description of how the element should integrate].

Merge the provided images by taking [style/background from image 1] and applying it to [subject from image 2]. Ensure the final composition looks natural and consistent in lighting and perspective.

Combine the provided images so that [object from image 1] is realistically integrated into [environment from image 2], preserving shadows and reflections.

From the provided images, replace [clothing/object from image 1] with [clothing/object from image 2], making sure the final subject looks realistic and seamlessly styled.

Using the provided images, overlay [graphic/logo/text from image 2] onto [surface/object from image 1], matching folds, shadows, and lighting.

Compose a scene where [character/subject from image 1] is placed into [scene from image 2], ensuring natural scale and perspective.

Blend [color palette/lighting from image 1] into [image 2], so the final combined image shares the same mood and tones.

Take [facial expression from image 1] and apply it to [person in image 2], preserving identity while transferring the expression.

Using the provided images, create a collage where [elements from image 1, 2, and 3] are arranged in [layout description], with consistent style and background.
🛠️ Если нет шаблона

Создавай новый промт в стиле:

Опиши объект конкретно (название, цвет, форма, детали).

Укажи действие (add, remove, replace, modify).

Добавь условия (свет, перспектива, стиль, настроение, композиция).

Обязательно сохрани идентичность объектов и реалистичность сцены, если пользователь не требует иного.

Используй расширения: cinematic lighting, pastel palette, isometric 3D, cyberpunk aesthetic, noir mood, watercolor painting, futuristic neon, golden hour glow, ultra-detailed, photorealistic.

📌 Алгоритм работы модели:

Прочитать мой черновик.

Определить: Single image или Multi-image.

Если есть готовый шаблон → применить его.

Если нет → придумать новый промт, максимально детализированный и в духе библиотеки. 

В своем ответе написать **ИСКЛЮЧИТЕЛЬНО ГОТОВЫЙ ФИНАЛЬНЫЙ ПРОМТ**, **Н** ДОБАВЛЯЙ СВОИ КОММЕНТАРИИ ИЛИ РАЗМЫШЛЕНИЯ

Промт всегда на английском.`;

/* ===== Хранилище ===== */
function loadHistory(){ try{ const v5 = localStorage.getItem('nb_history_v5'); if(v5) return JSON.parse(v5); const prev = localStorage.getItem('nb_history_v4') || localStorage.getItem('nb_history_v3') || localStorage.getItem('nb_history_v2') || localStorage.getItem('nb_history'); if(prev){ const arr = JSON.parse(prev); localStorage.setItem('nb_history_v5', JSON.stringify(arr)); return arr; } return []; }catch{ return []; } }
function saveHistory(){ try{ localStorage.setItem('nb_history_v5', JSON.stringify(state.history)); }catch(e){} }

/* ===== Мини-утилиты ===== */
function DPR(){ return window.devicePixelRatio || 1; }
function parseAR(str){ const m = (str||'').split(':'); const a = Math.max(parseFloat(m[0]||'1'), 1e-6); const b = Math.max(parseFloat(m[1]||'1'), 1e-6); return a/b; }
function iconDownload(){ return `<svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M12 3v10m0 0l-4-4m4 4l4-4M5 21h14" stroke="#cfe6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`; }
function iconDownloadSmall(){ return `<svg width="12" height="12" viewBox="0 0 24 24" fill="none"><path d="M12 4v9m0 0l-3-3m3 3l3-3M5 20h14" stroke="#cfe6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`; }
function iconX(){ return `<svg width="14" height="14" viewBox="0 0 24 24" fill="none"><path d="M6 6l12 12M18 6L6 18" stroke="#cfe6ff" stroke-width="2" stroke-linecap="round"/></svg>`; }
function makeId(){ return Math.random().toString(36).slice(2)+Date.now().toString(36); }
function delay(ms){ return new Promise(r=>setTimeout(r, ms)); }

/* ===== Кэш blob URL ===== */
const blobUrlCache = new Map(); const BLOB_CACHE_LIMIT = 32;
function revokeOldIfNeeded(){ if(blobUrlCache.size<=BLOB_CACHE_LIMIT) return; const [k,v]=blobUrlCache.entries().next().value||[]; if(k&&v){URL.revokeObjectURL(v.url); blobUrlCache.delete(k);} }
async function getBlobUrl(dataURL){ if(!dataURL) return '#'; const hit = blobUrlCache.get(dataURL); if(hit){ hit.ts=Date.now(); return hit.url; } const blob = await (await fetch(dataURL)).blob(); const url = URL.createObjectURL(blob); blobUrlCache.set(dataURL, {url, ts:Date.now()}); revokeOldIfNeeded(); setTimeout(()=>{ const rec=blobUrlCache.get(dataURL); if(rec && Date.now()-rec.ts>120000){URL.revokeObjectURL(rec.url); blobUrlCache.delete(dataURL);} },130000); return url; }

/* ===== Вёрстка/канвас ===== */
function calcViewportSize(){
  const mainRect = document.querySelector('main').getBoundingClientRect();
  const winArea = window.innerWidth * window.innerHeight;
  const targetArea = winArea * 0.70;
  const availW = mainRect.width;
  const availH = mainRect.height - 8;
  const ar = getCurrentAspect();

  let w = Math.sqrt(targetArea * ar);
  let h = w / ar;
  if(w > availW){ w = availW; h = w / ar; }
  if(h > availH){ h = availH; w = h * ar; }
  w = Math.max(160, Math.floor(w));
  h = Math.max(160, Math.floor(h));

  const dpr = DPR();
  els.canvas.style.width = w+'px'; els.canvas.style.height = h+'px';
  els.canvas.width = Math.floor(w * dpr); els.canvas.height = Math.floor(h * dpr);

  els.imgWrap.style.width = w+'px'; els.imgWrap.style.height = h+'px';
  els.inputGrid.style.width = '100%'; els.inputGrid.style.height = '100%';
}
function getCurrentAspect(){
  if(state.showResults && state.outputs.length){ return 1; }
  if(state.inputs.length===0){ return state.pureAR || 1; }
  if(state.inputs.length===1){ const i=state.inputs[0]; return i.w/i.h; }
  const sum = state.inputs.reduce((a,b)=>a+(b.w/b.h),0); return sum/state.inputs.length;
}
function clearCanvas(){ const ctx = els.canvas.getContext('2d'); ctx.clearRect(0,0,els.canvas.width,els.canvas.height); }
function drawBitmap(bmp){
  const ctx = els.canvas.getContext('2d'); const dpr = DPR();
  const cssW = parseInt(els.canvas.style.width)||els.canvas.width/dpr;
  const cssH = parseInt(els.canvas.style.height)||els.canvas.height/dpr;
  els.canvas.width = Math.floor(cssW * dpr); els.canvas.height = Math.floor(cssH * dpr);
  ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
  ctx.clearRect(0,0,els.canvas.width,els.canvas.height);
  const scale = Math.min(els.canvas.width/bmp.width, els.canvas.height/bmp.height);
  const dw = Math.max(1, Math.floor(bmp.width * scale));
  const dh = Math.max(1, Math.floor(bmp.height * scale));
  const dx = Math.floor((els.canvas.width - dw)/2); const dy = Math.floor((els.canvas.height - dh)/2);
  ctx.drawImage(bmp, dx, dy, dw, dh);
}
function setResultImg(dataURL){
  els.imgView.src = dataURL || '';
  if(dataURL){
    els.imgWrap.style.display = 'block';
    els.imgWrap.href = '#';
    ensureAnchorBlobHref(els.imgWrap, dataURL);
    const idx = state.outputs.length ? (state.currentIdx+1) : 0;
    els.imgWrap.download = state.outputs.length ? `variant-${idx}.png` : `source.png`;
  }
  else{
    els.imgWrap.style.display = 'none';
    els.imgWrap.href = '#';
  }
}
async function redrawCurrent(){
  const showResult = state.showResults && state.outputs.length>0;
  els.inputGrid.classList.toggle('show', !showResult && state.inputs.length>0);
  els.stage.classList.toggle('has-inputs', state.inputs.length>0);

  if(!showResult){
    setResultImg(''); clearCanvas(); renderInputGrid(); updateVariantBadge(); toggleCarousel(); updateDropzoneVisibility(); return;
  }
  const url = state.outputs[state.currentIdx]?.dataURL;
  setResultImg(url);
  const blob = await (await fetch(url)).blob();
  const bmp = await createImageBitmap(blob);
  if(Math.abs(getCurrentAspect() - (bmp.width/bmp.height)) > 0.001){ calcViewportSize(); }
  drawBitmap(bmp); updateVariantBadge(); toggleCarousel(); updateDropzoneVisibility();
}
function updateVariantBadge(){
  const show = (state.outputs.length>1 && state.showResults);
  els.variantBadge.classList.toggle('hidden', !show);
  if(show){
    const tag = state.outputs[state.currentIdx]?.tag;
    els.variantBadge.textContent = tag ? `${tag} · ${state.currentIdx+1}/${state.outputs.length}` : `Вариант ${state.currentIdx+1} / ${state.outputs.length}`;
  }
}
function toggleCarousel(){ els.carouselNav.classList.toggle('active', state.outputs.length>1 && state.showResults); }
function setShowResults(flag){ state.showResults = !!flag; redrawCurrent(); }

/* ===== Навигация по вариантам ===== */
function setIndex(i){ if(!state.outputs.length) return; state.currentIdx = ((i%state.outputs.length)+state.outputs.length)%state.outputs.length; redrawCurrent(); }
function setupNav(){
  els.prevBtn.addEventListener('click', ()=> setIndex(state.currentIdx-1));
  els.nextBtn.addEventListener('click', ()=> setIndex(state.currentIdx+1));
  let sx=0, dx=0, sw=false; els.canvas.addEventListener('pointerdown', e=>{sw=true; sx=e.clientX;});
  window.addEventListener('pointerup', e=>{ if(!sw) return; sw=false; dx=e.clientX-sx; if(Math.abs(dx)>48 && state.outputs.length>1 && state.showResults){ if(dx>0) setIndex(state.currentIdx-1); else setIndex(state.currentIdx+1);} });
  window.addEventListener('keydown', e=>{
    if(e.key==='ArrowLeft' && state.outputs.length>1 && state.showResults) setIndex(state.currentIdx-1);
    else if(e.key==='ArrowRight' && state.outputs.length>1 && state.showResults) setIndex(state.currentIdx+1);
    else if(e.key==='Home' && state.outputs.length>0 && state.showResults) setIndex(0);
    else if(e.key==='End' && state.outputs.length>0 && state.showResults) setIndex(state.outputs.length-1);
    else if((e.ctrlKey||e.metaKey) && e.key==='Enter') els.sendBtn.click();
    else if(e.key==='Escape') clearScene();
  });
  els.toggleViewBtn.addEventListener('click', ()=>{ if(!state.outputs.length){ toast('Нет результатов'); return; } setShowResults(!state.showResults); });
}

/* ===== Загрузка изображений (dnd/paste/picker) ===== */
let lastDropStamp = 0;
function setupLoaders(){
  const handleFiles = async (files, {switchToInputs=false}={})=>{
    const imgs = [...files].filter(f=>f.type.startsWith('image/'));
    if(!imgs.length) return;
    const space = MAX_INPUTS - state.inputs.length;
    if(space<=0){ toast('Можно до 4 изображений'); return; }
    const take = imgs.slice(0, space);
    const skipped = imgs.length - take.length;
    if(skipped>0) toast(`Принято ${take.length}, лишние отклонены`);
    for(const f of take){ await addInputFile(f); }
    if(state.inputs.length>0){ els.dz.classList.add('hide'); }
    if(switchToInputs || state.outputs.length){ setShowResults(false); }
    renderInputGrid();
    updateArVisibility(); updateDropzoneVisibility();
  };
  function onDrop(e){
    e.preventDefault(); e.stopPropagation();
    const now = Date.now(); if(now - lastDropStamp < 80) return; lastDropStamp = now;
    if(e.dataTransfer?.files?.length){ return handleFiles(e.dataTransfer.files, {switchToInputs:true}); }
    const txt = e.dataTransfer.getData('text/uri-list') || e.dataTransfer.getData('text/plain');
    if(txt && /^data:image\//.test(txt)){
      fetch(txt).then(r=>r.blob()).then(blob=>{
        handleFiles([new File([blob],'dropped.png',{type: blob.type||'image/png'})], {switchToInputs:true});
      });
    }
  }
  els.dz.addEventListener('click', openPicker);
  els.dz.addEventListener('dragover', e=>{ e.preventDefault(); e.stopPropagation(); els.dz.style.borderColor='#345'; });
  els.dz.addEventListener('dragleave', e=>{ e.stopPropagation(); els.dz.style.borderColor='#243140'; });
  els.stage.addEventListener('dragover', e=>{ e.preventDefault(); e.stopPropagation(); });
  els.stage.addEventListener('drop', onDrop);
  window.addEventListener('paste', async e=>{
    const items = [...(e.clipboardData?.items||[])].filter(i=>i.type.startsWith('image/'));
    if(items.length){ const files = await Promise.all(items.map(i=>i.getAsFile())); handleFiles(files, {switchToInputs:true}); }
  });
  els.openPickerBtn.addEventListener('click', openPicker);
  els.fileInput.addEventListener('change', e=> handleFiles(e.target.files||[], {switchToInputs:true}));
  async function openPicker(){
    try{
      if(window.showOpenFilePicker){
        const hs = await showOpenFilePicker({ multiple:true, types:[{description:"Images", accept:{'image/*':['.png','.jpg','.jpeg','.webp','.bmp','.gif']}}], excludeAcceptAllOption:false });
        const files = await Promise.all(hs.map(h=>h.getFile()));
        handleFiles(files, {switchToInputs:true});
      }else{ els.fileInput.click(); }
    }catch(_){/* user cancelled */}
  }
}
async function addInputFile(file){
  const sig = `${file.name}|${file.size}|${file.lastModified||0}`;
  if(state.inputs.some(x=> x.sig === sig)) return;
  const blob = file instanceof Blob ? file : new Blob([file], {type:file.type||'image/png'});
  const dataURL = await blobToDataURL(blob);
  if(state.inputs.some(x=> x.dataURL === dataURL)) return;
  const bmp = await createImageBitmap(blob);
  const id = makeId();
  const thumb = await makeThumbCover(blob, 56,56);
  state.inputs.push({id, sig, dataURL, blob, w:bmp.width, h:bmp.height, mime: blob.type, createdAt: Date.now(), thumb, perPrompt:''});
  setActive(id); calcViewportSize(); redrawCurrent();
}
function removeInput(id){
  const idx = state.inputs.findIndex(x=>x.id===id);
  if(idx<0) return;
  state.inputs.splice(idx,1);
  if(state.activeId===id) state.activeId = state.inputs[0]?.id || null;
  if(state.inputs.length===0) { els.dz.classList.remove('hide'); }
  renderInputGrid(); redrawCurrent(); updateArVisibility(); updateDropzoneVisibility();
}

/* ===== История ===== */
function pruneHistory(){ while(state.history.length>MAX_HISTORY) state.history.shift(); saveHistory(); renderHistory(); }
function saveHistoryItem(item){ state.history.push(item); pruneHistory(); }
function clearHistory(){ state.history=[]; saveHistory(); renderHistory(); }
function renderHistory(){
  const wrap = els.history; wrap.innerHTML = '';
  state.history.slice().reverse().forEach((h)=>{
    const card = document.createElement('div'); card.className='hist-card'; card.role='listitem';
    const top = document.createElement('div'); top.className='hist-top';
    const meta = document.createElement('div'); meta.className='hist-meta'; meta.textContent = new Date(h.time).toLocaleString();
    const actions = document.createElement('div'); actions.className='hist-actions';
    const dl = document.createElement('a'); dl.className='dl-btn'; dl.href = (h.outputs && h.outputs[0]) || (h.srcList?.[0]) || '#'; dl.download='history-image.png'; dl.innerHTML = iconDownload();
    dl.addEventListener('click', async (e)=>{ const href = dl.getAttribute('href')||''; if(!href || href.startsWith('blob:')) return; e.preventDefault(); dl.href = await getBlobUrl(href); setTimeout(()=> dl.click(), 0); });
    actions.appendChild(dl); top.appendChild(meta); top.appendChild(actions); card.appendChild(top);
    const prRU = document.createElement('div'); prRU.className='tiny'; prRU.style.color='#bcd'; prRU.style.marginTop='-2px'; prRU.textContent = h.promptRU ? `RU: ${h.promptRU}` : 'RU: —';
    const prEN = document.createElement('div'); prEN.className='tiny'; prEN.style.color='#9fe'; prEN.textContent = h.promptEN ? `EN: ${h.promptEN}` : 'EN: —';
    card.appendChild(prRU); card.appendChild(prEN);
    const row = document.createElement('div'); row.className='thumbs-row';
    const outs = (h.outputs?.length ? h.outputs : h.srcList||[]);
    outs.forEach((dataURL,idx)=>{
      const it = document.createElement('div'); it.className='thumb-it'; it.title = `Вариант ${idx+1}`;
      const img = document.createElement('img'); img.src = dataURL; img.draggable = true;
      img.addEventListener('dragstart', e=>{
        e.dataTransfer.setData('text/uri-list', dataURL);
        e.dataTransfer.setData('text/plain', dataURL);
        e.dataTransfer.setData('DownloadURL', `image/png:history-${idx+1}.png:${dataURL}`);
      });
      img.addEventListener('click', ()=> restoreHistoryItem(h.id, idx));
      const dls = document.createElement('a'); dls.className = 'thumb-dl'; dls.href = dataURL; dls.download = `history-${idx+1}.png`; dls.innerHTML = iconDownloadSmall();
      dls.addEventListener('click', async (e)=>{ const href = dls.getAttribute('href')||''; if(!href || href.startsWith('blob:')) return; e.preventDefault(); dls.href = await getBlobUrl(href); setTimeout(()=> dls.click(), 0); });
      it.appendChild(img); it.appendChild(dls); row.appendChild(it);
    });
    card.appendChild(row);
    wrap.appendChild(card);
  });
}
async function restoreHistoryItem(id, variantIdx=0){
  const h = state.history.find(x=>x.id===id); if(!h) return;
  els.dz.classList.add('hide');
  state.inputs = (h.srcList||[]).map((url,i)=>({id: makeId(), dataURL: url, blob: null, w: (h.srcMeta?.[i]?.w)||0, h: (h.srcMeta?.[i]?.h)||0, mime:'image/png', createdAt: h.time+(i||0), thumb: url, perPrompt: (h.perImagePrompts?.[i]||'') }));
  state.activeId = state.inputs[0]?.id || null;
  state.outputs = (h.outputs||[]).map(x=>({dataURL:x, mime:'image/png'}));
  state.currentIdx = Math.min(variantIdx, Math.max(0, state.outputs.length-1));
  els.prompt.value = h.promptRU || h.promptEN || '';
  setShowResults(!!state.outputs.length);
  calcViewportSize(); await redrawCurrent(); toggleCarousel(); renderInputGrid(); updateActiveDetails(); updateArVisibility(); updateDropzoneVisibility();
}

/* ===== Пер-промт на активное изображение ===== */
function updateActiveDetails(){ if(state.activeId) setActive(state.activeId); else setActive(null); }
function setActive(id){
  state.activeId = id;
  renderInputGrid();
  const it = state.inputs.find(x=>x.id===id);
  if(!it){ els.activeMeta.textContent = 'Нет активного изображения'; els.activePerPrompt.classList.add('hidden'); return; }
  els.activeMeta.textContent = `Активное: ${it.w}×${it.h}, ${it.mime || 'image'}, загружено ${new Date(it.createdAt).toLocaleString()}`;
  if(state.perImage && state.inputs.length>1){ els.activePerPrompt.classList.remove('hidden'); els.activePerPrompt.value = it.perPrompt || ''; }
  else { els.activePerPrompt.classList.add('hidden'); }
}
els.activePerPrompt?.addEventListener('input', (e)=>{ if(!state.activeId) return; const it = state.inputs.find(x=>x.id===state.activeId); if(it){ it.perPrompt = e.target.value; } });

function renderInputGrid(){
  const grid = els.inputGrid; grid.innerHTML = '';
  const n = state.inputs.length;
  grid.classList.remove('grid-1','grid-2','grid-3','grid-4');
  grid.classList.add(`grid-${Math.min(Math.max(n,1),4)}`);
  state.inputs.forEach((it, idx)=>{
    const tile = document.createElement('div');
    tile.className = `tile i${idx} grid-${n}` + (state.activeId===it.id ? ' active':'');
    const img = document.createElement('img'); img.src = it.dataURL; img.alt = `Изображение ${idx+1}`; tile.appendChild(img);
    const btn = document.createElement('button'); btn.className='close'; btn.innerHTML = iconX(); btn.title='Удалить';
    btn.addEventListener('click', ()=>{ tile.classList.add('removing'); setTimeout(()=> removeInput(it.id), 160); });
    tile.addEventListener('click', ()=> setActive(it.id));
    tile.appendChild(btn);
    grid.appendChild(tile);
  });
  updatePerImageVisibility();
}
function updatePerImageVisibility(){
  const show = state.inputs.length > 1;
  els.perImageBtn.classList.toggle('hidden', !show);
  if(!show){
    state.perImage = false;
    updatePerImageBtn();
    els.activePerPrompt.classList.add('hidden');
  }
  updatePerImageBtn();
}

function updatePerImageBtn(){
  els.perImageBtn.classList.toggle('active', state.perImage);
}

/* ===== Dropzone visibility ===== */
function updateDropzoneVisibility(){
  const noInputs = state.inputs.length===0;
  const noResults = state.outputs.length===0;
  const show = noInputs && noResults && !state.generating;
  els.dz.classList.toggle('hide', !show);
}

/* ===== Переводчик RU→EN (для обычной генерации) ===== */
async function translateRuToEn(text){
  const src = (text||'').toString();
  if(!src.trim()) return '';
  const chunks = splitSmart(src, 450);
  const out = [];
  for(const ch of chunks){
    try{ out.push(await translateChunkMyMemory(ch)); }
    catch{ out.push(`[ru] ${ch}`); }
  }
  return out.join('');
}
async function translateListRuToEn(list){ const results = []; for(const s of list){ results.push(await translateRuToEn(s||'')); } return results; }
function splitSmart(text, max=450){
  const t = text.toString(); if(t.length<=max) return [t];
  const res=[]; let i=0;
  while(i < t.length){
    let end = Math.min(i+max, t.length);
    const slice = t.slice(i, end);
    let cut = -1;
    const prefer = /[\n\.!\?;:,]/g; let m;
    while((m = prefer.exec(slice))!==null){ cut = m.index; }
    if(cut<0){ const w = slice.lastIndexOf(' '); if(w>0) cut = w; }
    if(cut<0){ res.push(slice); i = end; } else { res.push(slice.slice(0, cut+1)); i += cut+1; }
  }
  return res;
}
async function translateChunkMyMemory(ch){
  const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(ch)}&langpair=ru|en`;
  const r = await fetch(url, {method:'GET'}); if(!r.ok) throw new Error('translate http '+r.status);
  const j = await r.json(); const s = (j?.responseData?.translatedText||'').toString(); if(!s) throw new Error('translate empty'); return s;
}

/* ===== Диагностика блокировок / извлечение ===== */
function readBlockReason(j){
  const pf = j?.promptFeedback;
  if(pf?.blockReason) return { reason: pf.blockReason, details: pf.safetyRatings || [] };
  const cand = (j?.candidates||[])[0];
  if(cand?.finishReason === 'SAFETY') return { reason: 'SAFETY', details: cand.safetyRatings || [] };
  return null;
}
function extractTexts(json){
  const out=[]; for(const c of (json?.candidates||[])){
    const parts = c?.content?.parts||[];
    for(const p of parts){ if(typeof p?.text==='string' && p.text.trim()) out.push(p.text); }
  } return out;
}
function extractImages(json){
  const out=[]; for(const c of (json?.candidates||[])){
    const parts = c?.content?.parts||[];
    for(const p of parts){
      const inline = p.inlineData || p.inline_data;
      if(inline?.data){
        const mime = inline.mimeType || inline.mime_type || 'image/png';
        out.push({ dataURL:`data:${mime};base64,${inline.data}`, mime });
      }
    }
  } return out;
}

/* ===== fetch с ретраями ===== */
async function fetchWithRetry(url, init, {retries=1, baseDelay=600, timeoutMS=60000}={}){
  let attempt=0, lastErr=null;
  for(; attempt<=retries; attempt++){
    const ctrl = new AbortController(); const to = setTimeout(()=>ctrl.abort(), timeoutMS);
    try{
      const res = await fetch(url, {...init, signal: ctrl.signal});
      clearTimeout(to);
      if(!res.ok){
        const txt = await res.text().catch(()=> '');
        const err = new Error(`HTTP ${res.status} ${res.statusText} :: ${txt.slice(0,400)}`);
        err.status = res.status; throw err;
      }
      return await res.json();
    }catch(e){
      lastErr = e; if(e.name==='AbortError') lastErr = new Error('Timeout');
      if(attempt===retries) break;
      const jitter = baseDelay * (2**attempt) + Math.random()*333; await delay(jitter);
    }
  }
  throw lastErr||new Error('Network error');
}

/* ===== Антидубли для API ===== */
const inFlight = new Set();
function makeReqSignature(bodyObj){
  try{ return JSON.stringify(bodyObj); }catch{ return String(Math.random()); }
}

/* ===== Общая отправка (обычный режим) ===== */
async function callGeminiSingle({globalPromptEN, perImage=false, perPromptsEN=[]}){
  const parts = [];
  const gp = (globalPromptEN||'').trim();
  if(gp) parts.push({text: gp});
  if(perImage && state.inputs.length){
    state.inputs.forEach((it, idx)=>{
      const pEN = (perPromptsEN[idx]||'').trim();
      if(pEN) parts.push({text: `Image ${idx+1}: ${pEN}`});
      parts.push({ inline_data: { mime_type: it.mime || 'image/png', data: (it.dataURL.split(',')[1]||'') } });
    });
  }else if(state.inputs.length){
    state.inputs.forEach(it=>{
      parts.push({ inline_data: { mime_type: it.mime || 'image/png', data: (it.dataURL.split(',')[1]||'') } });
    });
  }else{
    if(!gp){ throw new Error('EMPTY_REQUEST'); }
  }

  const safety = [
    'HARM_CATEGORY_HARASSMENT',
    'HARM_CATEGORY_HATE_SPEECH',
    'HARM_CATEGORY_SEXUALLY_EXPLICIT',
    'HARM_CATEGORY_DANGEROUS_CONTENT'
  ].map(c => ({category:c, threshold:'BLOCK_NONE'}));

  const body = { 
    contents: [{role:'user', parts}], 
    generationConfig:{ responseModalities:['IMAGE'], seed: Math.floor(Math.random()*2**31) }, 
    safetySettings: safety 
  };

  const sig = makeReqSignature(body);
  if(inFlight.has(sig)) { console.warn('[dedupe] skipped identical in-flight request'); throw new Error('DEDUPED'); }
  inFlight.add(sig);
  try{
    let res = await fetchWithRetry(ENDPOINT, { method:'POST', headers:{ 'Content-Type':'application/json', 'x-goog-api-key': API_KEY }, body: JSON.stringify(body) }, {retries:1, baseDelay:700, timeoutMS:65000});
    let outs = extractImages(res);
    const br = readBlockReason(res);

    if((!outs || outs.length===0) && !br){
      body.generationConfig.seed = Math.floor(Math.random()*2**31);
      res = await fetchWithRetry(ENDPOINT, { method:'POST', headers:{ 'Content-Type':'application/json', 'x-goog-api-key': API_KEY }, body: JSON.stringify(body) }, {retries:0, baseDelay:600, timeoutMS:65000});
      outs = extractImages(res);
    }

    if(br && (!outs || outs.length===0)){
      const err = new Error('BLOCKED'); err.block = br; throw err;
    }
    if(!outs || outs.length===0){ const err = new Error('NO_IMAGE'); err.detail = res; throw err; }
    return outs;
  } finally {
    inFlight.delete(sig);
  }
}

/* ===== Кастомная отправка: текст + одиночный dataURL (для кнопки «Обработать фото») ===== */
async function callGeminiWithPromptAndDataURL({promptText, dataURL}){
  const parts = [];
  if(promptText && String(promptText).trim()) parts.push({text: String(promptText)});
  parts.push({ inline_data: { mime_type: 'image/png', data: (dataURL.split(',')[1]||'') } });

  const safety = [
    'HARM_CATEGORY_HARASSMENT',
    'HARM_CATEGORY_HATE_SPEECH',
    'HARM_CATEGORY_SEXUALLY_EXPLICIT',
    'HARM_CATEGORY_DANGEROUS_CONTENT'
  ].map(c => ({category:c, threshold:'BLOCK_NONE'}));

  const body = { 
    contents: [{role:'user', parts}], 
    generationConfig:{ responseModalities:['IMAGE'], seed: Math.floor(Math.random()*2**31) }, 
    safetySettings: safety 
  };

  const sig = makeReqSignature(body);
  if(inFlight.has(sig)) { console.warn('[dedupe] skipped identical in-flight request'); throw new Error('DEDUPED'); }
  inFlight.add(sig);
  try{
    let res = await fetchWithRetry(ENDPOINT, { method:'POST', headers:{ 'Content-Type':'application/json', 'x-goog-api-key': API_KEY }, body: JSON.stringify(body) }, {retries:1, baseDelay:700, timeoutMS:65000});
    let outs = extractImages(res);
    const br = readBlockReason(res);

    if((!outs || outs.length===0) && !br){
      body.generationConfig.seed = Math.floor(Math.random()*2**31);
      res = await fetchWithRetry(ENDPOINT, { method:'POST', headers:{ 'Content-Type':'application/json', 'x-goog-api-key': API_KEY }, body: JSON.stringify(body) }, {retries:0, baseDelay:600, timeoutMS:65000});
      outs = extractImages(res);
    }

    if(br && (!outs || outs.length===0)){
      const err = new Error('BLOCKED'); err.block = br; throw err;
    }
    if(!outs || outs.length===0){ const err = new Error('NO_IMAGE'); err.detail = res; throw err; }
    return outs;
  } finally {
    inFlight.delete(sig);
  }
}

/* ===== Параллельная отправка (обычная) ===== */
async function generateParallelStaggered(total, globalPromptEN, perImage, perPromptsEN){
  total = Math.min(Math.max(total,1),10);
  const token = ++state.genToken;
  state.cancelled = false;
  state.generating = true;
  els.sendBtn.dataset.busy = '1';
  showLoader(true);
  let done = 0, firstPainted = false, hadAny = false;
  els.progressText.textContent = `Готово ${done}/${total}`;
  const stagger = 200;

  const launches = [];
  for(let i=0;i<total;i++){
    launches.push((async (idx)=>{
      await delay(idx*stagger);
      if(state.cancelled || token!==state.genToken) return;
      try{
        let outs = await callGeminiSingle({globalPromptEN, perImage, perPromptsEN});
        if(state.cancelled || token!==state.genToken) return;

        if(outs && outs.length && state.inputs.length===0){
          const arStr = els.arSelect.value || '1:1';
          if(arStr !== '1:1'){
            const processed = [];
            for(const img of outs){
              if(state.cancelled || token!==state.genToken) return;
              processed.push(await enforceAspectOnDataURL(img.dataURL, arStr, 'contain'));
            }
            outs = processed;
          }
        }

        if(outs && outs.length){
          hadAny = true;
          for(const img of outs){ 
            if(state.cancelled || token!==state.genToken) return;
            state.outputs.push(img); 
            state.currentIdx = state.outputs.length-1; 
          }
          setShowResults(true);
          if(!firstPainted){ firstPainted = true; showLoader(false); } 
          await redrawCurrent();
        }
      }catch(e){
        console.warn('[gen item error]', e);
        if(e?.message==='BLOCKED' && e.block){
          showToast('Ошибка: модерация/политики — см. консоль', 2400);
          console.warn('Block reason:', e.block);
        }else if(e?.message==='DEDUPED'){
        }else if(e?.message==='NO_IMAGE'){
          showToast('Модель не вернула изображение', 1800);
        }else{
          showToast('Сетевая ошибка/таймаут', 1800);
        }
      }finally{
        done++; els.progressText.textContent = `Готово ${Math.min(done,total)}/${total}`;
      }
    })(i));
  }
  await Promise.allSettled(launches);
  state.generating = false;
  delete els.sendBtn.dataset.busy;
  if(!firstPainted){ showLoader(false); }
  updateDropzoneVisibility();

  return hadAny;
}

/* ====== КНОПКА «ОБРАБОТАТЬ ФОТО» (A: исходник + PROMPT_1, B: ЧБ + PROMPT_2) ====== */

/* Грейскейл конверсия dataURL */
async function toGrayscaleDataURL(srcDataURL){
  const blob = await (await fetch(srcDataURL)).blob();
  const bmp = await createImageBitmap(blob);
  const W = bmp.width, H = bmp.height;
  const off = ('OffscreenCanvas' in window) ? new OffscreenCanvas(W,H) : Object.assign(document.createElement('canvas'), {width:W, height:H});
  if(!('width' in off)){ off.width=W; off.height=H; }
  const ctx = off.getContext('2d');
  ctx.drawImage(bmp, 0,0, W,H);
  const imgData = ctx.getImageData(0,0,W,H);
  const d = imgData.data;
  for(let i=0;i<d.length;i+=4){
    const r=d[i], g=d[i+1], b=d[i+2];
    const y = Math.round(0.2126*r + 0.7152*g + 0.0722*b);
    d[i]=d[i+1]=d[i+2]=y;
  }
  ctx.putImageData(imgData,0,0);
  const outBlob = off.convertToBlob ? await off.convertToBlob({type:'image/png', quality:.96}) : await new Promise(r=> off.toBlob(r,'image/png', .96));
  return await blobToDataURL(outBlob);
}

/* Основная логика обработки фото */
async function onProcessPhoto(){
  if(state.generating) return;
  if(!state.inputs.length){ showToast('Добавь фото для обработки', 2200); return; }

  // Берём первую загруженную фотографию
  const base = state.inputs[0];
  const baseDataURL = base.dataURL;

  // Готовим ЧБ версию
  let bwDataURL = null;
  try{
    bwDataURL = await toGrayscaleDataURL(baseDataURL);
  }catch(e){
    console.warn('[grayscale] failed, fallback to original', e);
    bwDataURL = baseDataURL;
  }

  // Сколько итераций на вариант
  const n = Math.min(Math.max(parseInt(els.varCount.value)||1,1),10);
  const total = n*2; // A + B
  const token = ++state.genToken;
  state.cancelled = false;
  state.generating = true;
  els.processPhotoBtn.dataset.busy = '1';
  showLoader(true);
  state.outputs = []; state.currentIdx = 0; setShowResults(false);

  let done = 0, firstPainted = false, hadAny = false;
  els.progressText.textContent = `Готово ${done}/${total}`;
  const stagger = 200;

  // Хелпер пуша результатов с тегом
  async function pushOutsWithTag(outs, tag){
    if(!outs || !outs.length) return;
    hadAny = true;
    for(const img of outs){
      if(state.cancelled || token!==state.genToken) return;
      const obj = {...img, tag};
      state.outputs.push(obj);
      state.currentIdx = state.outputs.length-1;
    }
    setShowResults(true);
    if(!firstPainted){ firstPainted = true; showLoader(false); }
    await redrawCurrent();
  }

  const tasks = [];
  // Вариант A: исходное фото + PROMPT_1
  for(let i=0;i<n;i++){
    tasks.push((async (idx)=>{
      await delay(idx*stagger);
      if(state.cancelled || token!==state.genToken) return;
      try{
        const outs = await callGeminiWithPromptAndDataURL({promptText: PRESET_PROMPT_1, dataURL: baseDataURL});
        await pushOutsWithTag(outs, `A${idx+1}`);
      }catch(e){
        console.warn('[process A error]', e);
        if(e?.message==='BLOCKED' && e.block){ showToast('A: модерация/политики — см. консоль', 2400); console.warn('Block A:', e.block); }
        else if(e?.message==='NO_IMAGE'){ showToast('A: нет изображения от модели', 1800); }
        else if(e?.message!=='DEDUPED'){ showToast('A: сеть/таймаут', 1800); }
      }finally{
        done++; els.progressText.textContent = `Готово ${Math.min(done,total)}/${total}`;
      }
    })(i));
  }
  // Вариант B: ЧБ + PROMPT_2
  for(let i=0;i<n;i++){
    tasks.push((async (idx)=>{
      await delay((idx+n)*stagger);
      if(state.cancelled || token!==state.genToken) return;
      try{
        const outs = await callGeminiWithPromptAndDataURL({promptText: PRESET_PROMPT_2, dataURL: bwDataURL});
        await pushOutsWithTag(outs, `B${idx+1}`);
      }catch(e){
        console.warn('[process B error]', e);
        if(e?.message==='BLOCKED' && e.block){ showToast('B: модерация/политики — см. консоль', 2400); console.warn('Block B:', e.block); }
        else if(e?.message==='NO_IMAGE'){ showToast('B: нет изображения от модели', 1800); }
        else if(e?.message!=='DEDUPED'){ showToast('B: сеть/таймаут', 1800); }
      }finally{
        done++; els.progressText.textContent = `Готово ${Math.min(done,total)}/${total}`;
      }
    })(i));
  }

  await Promise.allSettled(tasks);
  state.generating = false;
  delete els.processPhotoBtn.dataset.busy;
  if(!firstPainted){ showLoader(false); }
  updateDropzoneVisibility();

  if(!hadAny){
    showToast('Не удалось получить изображения. Проверь входное фото или попробуй ещё раз.', 2800);
    return;
  }

  // Сохраняем в историю
  const item = {
    id: makeId(), time: Date.now(),
    promptRU: 'Обработать фото: PRESET A/B',
    promptEN: '',
    perImagePrompts: [],
    srcList: [baseDataURL, bwDataURL],
    srcMeta: [{w:base.w,h:base.h,mime:base.mime,createdAt:base.createdAt},{w:base.w,h:base.h,mime:'image/png',createdAt:Date.now()}],
    outputs: state.outputs.map(o=>o.dataURL),
    currentIdx: state.currentIdx,
  };
  saveHistoryItem(item);
  showToast('Готово', 1100);
}

/* ===== Magic: независимый поток ===== */
els.magicBtn.addEventListener('click', onMagic);
async function onMagic(){
  const draft = (els.prompt.value||'').trim();
  if(!draft){ showToast('Напиши черновик промта', 1600); return; }
  if(state.magic.busy){ showToast('Идёт Magic…', 1400); return; }
  state.magic.busy = true; els.magicBtn.dataset.busy = '1';
  try{
    const variants = await getMagicVariants(draft);
    if(!variants.length){ toast('Не удалось получить варианты'); return; }
    openMagicModal(variants);
  }catch(e){
    console.log('[magic] error', e);
    toast('Magic не сработал. Попробуй ещё раз.');
  }finally{
    state.magic.busy = false; delete els.magicBtn.dataset.busy;
  }
}
async function getMagicVariants(draft){
  const parts = [
    {text: MAGIC_ENHANCER_PROMPT},
    {text: `\n\nЧерновик:\n${draft}`}
  ];
  const body = { contents:[{role:'user', parts}] };
  const res = await fetchWithRetry(ENDPOINT, {
    method:'POST',
    headers:{ 'Content-Type':'application/json', 'x-goog-api-key': API_KEY },
    body: JSON.stringify(body)
  }, {retries:0, baseDelay:500, timeoutMS:45000});
  const texts = extractTexts(res);
  const joined = texts.join('\n');
  let variants = parseSuggestions(joined);
  if(variants.length<2){
    try{
      const res2 = await fetchWithRetry(ENDPOINT, { method:'POST', headers:{ 'Content-Type':'application/json', 'x-goog-api-key': API_KEY }, body: JSON.stringify(body) }, {retries:0, baseDelay:500, timeoutMS:45000});
      const texts2 = extractTexts(res2);
      variants = uniq([...variants, ...parseSuggestions(texts2.join('\n'))]);
    }catch{}
  }
  return uniq(variants).map(s=>s.trim()).filter(Boolean).slice(0,5);
}
function parseSuggestions(text){
  const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  let items = [];
  for(const l of lines){
    if(/^[\-\*•—]\s+/.test(l)){ items.push(l.replace(/^[\-\*•—]\s+/,'')); }
    else if(/^\d+[\.\)\]]\s+/.test(l)){ items.push(l.replace(/^\d+[\.\)\]]\s+/,'')); }
  }
  if(items.length>=2) return items;
  const paras = text.split(/\n\s*\n/).map(s=>s.trim()).filter(Boolean);
  if(paras.length>=2) return paras;
  return [text.trim()];
}
function uniq(arr){ return [...new Set(arr)]; }

/* ===== Magic modal ===== */
function openMagicModal(variants){
  state.magic.variants = variants;
  state.magic.selectedIdx = 0;
  const list = els.magicList; list.innerHTML = '';
  variants.forEach((v, i)=>{
    const row = document.createElement('label'); row.className='opt';
    const rb = document.createElement('input'); rb.type='radio'; rb.name='magicOpt'; rb.value=String(i); rb.checked = (i===0);
    rb.addEventListener('change', ()=> state.magic.selectedIdx = i);
    const pre = document.createElement('pre'); pre.textContent = v;
    row.appendChild(rb); row.appendChild(pre); list.appendChild(row);
  });
  els.magicModal.classList.add('show'); state.magic.open = true;
}
function closeMagicModal(){ els.magicModal.classList.remove('show'); state.magic.open = false; }
els.magicCancel.addEventListener('click', closeMagicModal);
els.magicApply.addEventListener('click', ()=>{
  const v = state.magic.variants[state.magic.selectedIdx] || '';
  if(v){ els.prompt.value = v; showToast('Черновик обновлён ✨', 1200); }
  closeMagicModal();
});
window.addEventListener('keydown', (e)=>{ if(state.magic.open && e.key==='Escape'){ closeMagicModal(); } });

/* ===== Переключатель перевода (localStorage) ===== */
function initTranslateBtn(){
  try{
    const raw = localStorage.getItem(TR_TOGGLE_KEY);
    state.translateEnabled = raw==null ? true : (raw==='1');
  }catch{ state.translateEnabled = true; }
  updateTranslateBtn();
  els.translateBtn.addEventListener('click', ()=>{
    state.translateEnabled = !state.translateEnabled;
    updateTranslateBtn();
    try{ localStorage.setItem(TR_TOGGLE_KEY, state.translateEnabled ? '1':'0'); }catch{}
  });
}
function updateTranslateBtn(){
  els.translateBtn.classList.toggle('active', state.translateEnabled);
  els.prompt.placeholder = state.translateEnabled
    ? 'Промт (RU/EN). Переведём на английский автоматически…'
    : 'Промт (RU/EN). Без авто-перевода.';
}

/* ===== AR: видимость селектора ===== */
function updateArVisibility(){
  const pure = state.inputs.length===0;
  els.arSelect.style.display = pure ? '' : 'none';
}

/* ===== Client-side AR enforcement ===== */
function getArWH(arStr, maxSide=1024){
  const [aw, ah] = (arStr||'1:1').split(':').map(x=>Math.max(parseFloat(x)||1, 1e-6));
  if(aw>=ah) return [maxSide, Math.round(maxSide*ah/aw)];
  return [Math.round(maxSide*aw/ah), maxSide];
}
async function enforceAspectOnDataURL(dataURL, arStr='1:1', mode='contain', bg='transparent'){
  try{
    const blob = await (await fetch(dataURL)).blob();
    const bmp = await createImageBitmap(blob);
    const [W,H] = getArWH(arStr, 1024);
    const off = ('OffscreenCanvas' in window) ? new OffscreenCanvas(W,H) : Object.assign(document.createElement('canvas'), {width:W, height:H});
    if(!('width' in off)) { off.width=W; off.height=H; }
    const ctx = off.getContext('2d');
    ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
    if(bg==='transparent'){ ctx.clearRect(0,0,W,H); } else { ctx.fillStyle = bg; ctx.fillRect(0,0,W,H); }
    const scale = (mode==='cover') ? Math.max(W/bmp.width, H/bmp.height) : Math.min(W/bmp.width, H/bmp.height);
    const dw = Math.max(1, Math.floor(bmp.width*scale));
    const dh = Math.max(1, Math.floor(bmp.height*scale));
    const dx = Math.floor((W - dw)/2), dy = Math.floor((H - dh)/2);
    ctx.drawImage(bmp, dx, dy, dw, dh);
    const outBlob = off.convertToBlob ? await off.convertToBlob({type:'image/png', quality:.96}) : await new Promise(r=> off.toBlob(r,'image/png', .96));
    const outDataURL = await blobToDataURL(outBlob);
    return { dataURL: outDataURL, mime: 'image/png' };
  }catch(e){ console.warn('[AR enforce failed]', e); return { dataURL, mime: 'image/png' }; }
}

/* ===== Replace / Reset ===== */
async function replaceOriginalWithCurrent(){
  if(!state.outputs.length){ toast('Нет результата для замены'); return; }
  if(state.inputs.length===0){ toast('Нет исходников'); return; }
  let target = state.activeId || state.inputs[0].id;
  const curUrl = state.outputs[state.currentIdx].dataURL;
  const blob = await (await fetch(curUrl)).blob();
  const bmp = await createImageBitmap(blob);
  const it = state.inputs.find(x=>x.id===target);
  Object.assign(it, { dataURL: curUrl, blob, w:bmp.width, h:bmp.height, mime: blob.type||'image/png', createdAt: Date.now() });
  renderInputGrid(); setActive(it.id);
  toast('Заменено в галерее');
}
function clearScene(){
  state.inputs = []; state.activeId=null; state.outputs=[]; state.currentIdx=0; setShowResults(false);
  clearCanvas(); setResultImg(''); els.dz.classList.remove('hide');
  els.carouselNav.classList.remove('active'); els.variantBadge.classList.add('hidden'); renderInputGrid(); updateActiveDetails(); updateArVisibility(); updateDropzoneVisibility();
}

/* ===== Общие утилиты ===== */
function blobToDataURL(blob){ return new Promise(r=>{ const fr=new FileReader(); fr.onload=()=>r(fr.result); fr.readAsDataURL(blob); }); }
function showLoader(on){ els.loader.classList.toggle('show', !!on); }
function showToast(text='Генерация…', ms=2400){ els.toast.textContent=text; els.toast.classList.add('show'); setTimeout(()=>els.toast.classList.remove('show'), ms); }
function toast(msg, ms=2200){ showToast(msg, ms); }
async function makeThumbCover(blob, w, h){
  const off = ('OffscreenCanvas' in window) ? new OffscreenCanvas(w,h) : document.createElement('canvas');
  off.width = w; off.height = h;
  const ctx = off.getContext('2d'); const bmp = await createImageBitmap(blob);
  const scale = Math.max(w/bmp.width, h/bmp.height);
  const sw = Math.floor(w/scale); const sh = Math.floor(h/scale);
  const sx = Math.max(0, Math.floor((bmp.width - sw)/2)); const sy = Math.max(0, Math.floor((bmp.height - sh)/2));
  ctx.clearRect(0,0,w,h); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';
  ctx.drawImage(bmp, sx, sy, sw, sh, 0,0, w,h);
  if(off.convertToBlob){ const b = await off.convertToBlob({type:'image/jpeg', quality:.9}); return await blobToDataURL(b); }
  return off.toDataURL('image/jpeg', .9);
}

/* ====== ПРЕСЕТЫ: работа с локальным файлом styles.json через File System Access API ====== */

const STYLES_HANDLE_KEY = 'stylesFileHandleV1'; // ключ в IndexedDB
let stylesFileHandle = null;

// IndexedDB mini-wrapper
const IDB_DB = 'nb_fs_db', IDB_STORE = 'handles';
function idbOpen(){ return new Promise((res,rej)=>{ const r=indexedDB.open(IDB_DB,1); r.onupgradeneeded=()=>{ r.result.createObjectStore(IDB_STORE); }; r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); });}
async function idbSet(key,val){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(IDB_STORE,'readwrite'); tx.objectStore(IDB_STORE).put(val,key); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); });}
async function idbGet(key){ const db=await idbOpen(); return new Promise((res,rej)=>{ const tx=db.transaction(IDB_STORE,'readonly'); const q=tx.objectStore(IDB_STORE).get(key); q.onsuccess=()=>res(q.result); q.onerror=()=>rej(q.error); });}

function fsSupported(){ return 'showOpenFilePicker' in window || 'showDirectoryPicker' in window; }

async function restoreStylesHandle(){
  try{
    const h = await idbGet(STYLES_HANDLE_KEY);
    if(!h) return false;
    // Проверяем доступ
    const q = await h.queryPermission({mode:'readwrite'});
    if(q === 'granted'){ stylesFileHandle = h; updateStylesPathHint(h); return true; }
    // Попробуем запросить (может потребоваться gesture — тогда просто вернём false)
    const p = await h.requestPermission({mode:'readwrite'}).catch(()=> 'denied');
    if(p === 'granted'){ stylesFileHandle = h; updateStylesPathHint(h); return true; }
  }catch(e){ console.warn('[restoreStylesHandle]', e); }
  return false;
}
function updateStylesPathHint(h){
  try{
    const name = h?.name || 'styles.json';
    els.stylesPathHint.textContent = `…\\${name}`;
  }catch{ els.stylesPathHint.textContent = 'не выбран'; }
}

async function linkStylesFile(){
  if(!fsSupported()){ showToast('FS API недоступен: Chromium + HTTPS/localhost', 3000); return; }
  try{
    const [fh] = await showOpenFilePicker({
      multiple:false,
      types:[{ description:'JSON', accept:{'application/json':['.json']} }],
      excludeAcceptAllOption:false
    });
    const p = await fh.requestPermission({mode:'readwrite'});
    if(p !== 'granted'){ showToast('Нет разрешения на запись', 2000); return; }
    stylesFileHandle = fh;
    await idbSet(STYLES_HANDLE_KEY, fh);
    updateStylesPathHint(fh);
    showToast('styles.json привязан', 1600);
    await refreshPresetsList();
  }catch(e){
    if(e?.name!=='AbortError') console.warn('[linkStylesFile]', e);
  }
}

async function readStylesArray(){
  if(stylesFileHandle){
    try{
      const file = await stylesFileHandle.getFile();
      const text = await file.text();
      if(!text.trim()) return [];
      const arr = JSON.parse(text);
      return Array.isArray(arr) ? arr : [];
    }catch(e){ console.warn('[readStylesArray]', e); return []; }
  }
  // Fallback в localStorage (если FS API нет/не выбран файл)
  try{ const raw = localStorage.getItem('nb_presets_fallback'); return raw ? JSON.parse(raw) : []; }catch{ return []; }
}
async function writeStylesArray(arr){
  if(stylesFileHandle){
    const writable = await stylesFileHandle.createWritable();
    await writable.write(JSON.stringify(arr, null, 2));
    await writable.close();
    return;
  }
  localStorage.setItem('nb_presets_fallback', JSON.stringify(arr));
}

/* UI: отрисовка списка пресетов с чекбоксами и превью */
function renderPresetList(presets){
  els.presetList.innerHTML = '';
  if(!presets.length){
    const empty = document.createElement('div');
    empty.className='small';
    empty.style.opacity='.8';
    empty.textContent = 'Пока пусто. Добавь пресет выше и сохрани.';
    els.presetList.appendChild(empty);
    return;
  }
  presets.forEach((p, i)=>{
    const row = document.createElement('label');
    row.className = 'opt';
    const cb = document.createElement('input'); cb.type='checkbox'; cb.value=String(p.id || i);
    const box = document.createElement('div'); box.className='grow';
    const title = document.createElement('div'); title.style.fontWeight='800'; title.style.marginBottom='4px';
    title.textContent = p.name || `preset #${i+1}`;
    const details = document.createElement('details');
    const summary = document.createElement('summary'); summary.textContent='Показать промт';
    const pre = document.createElement('pre'); pre.textContent = p.prompt || '';
    details.appendChild(summary); details.appendChild(pre);
    box.appendChild(title); box.appendChild(details);
    row.appendChild(cb); row.appendChild(box);
    els.presetList.appendChild(row);
  });
}

function populatePresetQuick(presets){
  const sel = els.presetQuick;
  sel.innerHTML = '';
  if(!presets.length){
    sel.classList.add('hidden');
    state.presets = [];
    return;
  }
  const def = document.createElement('option');
  def.value='';
  def.textContent='пресеты…';
  sel.appendChild(def);
  presets.forEach((p,i)=>{
    const opt = document.createElement('option');
    opt.value=String(i);
    opt.textContent = p.name || `preset #${i+1}`;
    sel.appendChild(opt);
  });
  sel.classList.remove('hidden');
  state.presets = presets;
}

/* Обновить список пресетов из файла */
async function refreshPresetsList(){
  const arr = await readStylesArray();
  renderPresetList(arr);
  populatePresetQuick(arr);
  return arr;
}

function onQuickPresetSelect(e){
  const idx = parseInt(e.target.value,10);
  if(isNaN(idx)) return;
  const p = state.presets[idx];
  if(!p) return;
  if(els.prompt.value) els.prompt.value += '\n';
  els.prompt.value += p.prompt || '';
  showToast('Пресет вставлен', 1000);
  e.target.selectedIndex = 0;
}

/* Сохранить новый пресет */
async function onSavePreset(){
  const name = (els.presetNameInput.value||'').trim();
  const prompt = (els.presetTextInput.value||'').trim();
  if(!name || !prompt){ showToast('Название и промт обязательны', 2000); return; }
  const list = await readStylesArray();
  const id = Date.now().toString(36);
  list.push({ id, name, prompt, createdAt: new Date().toISOString() });
  await writeStylesArray(list);
  els.presetNameInput.value=''; els.presetTextInput.value='';
  showToast('Пресет сохранён', 1200);
  await refreshPresetsList(); // автообновление
}

/* Вставить выбранные пресеты в поле промта (не заменяя) */
async function onInsertSelectedPresets(){
  const arr = await readStylesArray();
  const boxes = [...els.presetList.querySelectorAll('input[type="checkbox"]')];
  const picks = boxes.filter(b=>b.checked).map(b=> b.value);
  if(!picks.length){ showToast('Выбери хотя бы один пресет', 2000); return; }
  const chosen = arr.filter(p=> picks.includes(String(p.id || '')) || picks.includes(String(arr.indexOf(p))));
  if(!chosen.length){ showToast('Нечего вставлять', 1600); return; }
  const pieces = chosen.map(p=> `/* preset: ${p.name||''} */\n${p.prompt||''}`.trim());
  const toInsert = pieces.join('\n\n');
  if(els.prompt.value && !/\s$/.test(els.prompt.value)) els.prompt.value += '\n\n';
  els.prompt.value += toInsert;
  showToast('Промты добавлены к текущему', 1200);
}

/* Кнопки выбрать все/снять все */
function selectAllPresets(flag){
  const boxes = [...els.presetList.querySelectorAll('input[type="checkbox"]')];
  boxes.forEach(b=> b.checked = !!flag);
}

/* ====== UI: модал пресетов ====== */
function openPresetsModal(){
  els.presetsModal.classList.add('show');
}
function closePresetsModal(){
  els.presetsModal.classList.remove('show');
}

/* ===== Init / listeners ===== */
function handleViewportChange(){ calcViewportSize(); redrawCurrent(); }
function setupCoreUI(){
  // генерация
  els.sendBtn.addEventListener('click', onSend);
  els.closeBtn.addEventListener('click', clearScene);
  els.resetBtn.addEventListener('click', clearScene);
  els.clearHistBtn.addEventListener('click', ()=>{ if(confirm('Очистить историю?')) clearHistory(); });
  els.perImageBtn.addEventListener('click', ()=>{
    state.perImage = !state.perImage;
    updatePerImageBtn();
    updateActiveDetails();
  });
  els.presetQuick.addEventListener('change', onQuickPresetSelect);
  els.imgView.addEventListener('dblclick', replaceOriginalWithCurrent);
  els.arSelect.addEventListener('change', ()=>{ state.pureAR = parseAR(els.arSelect.value||'1:1'); calcViewportSize(); redrawCurrent(); });
  els.cancelBtn.addEventListener('click', ()=>{
    state.cancelled = true;
    state.genToken++; 
    state.generating = false;
    delete els.sendBtn.dataset.busy;
    delete els.processPhotoBtn.dataset.busy;
    delete els.openPresetsBtn.dataset.busy;
    showLoader(false);
    updateDropzoneVisibility();
    toast('Генерация отменена');
  });
  els.processPhotoBtn.addEventListener('click', onProcessPhoto);

  // пресеты
  els.openPresetsBtn.addEventListener('click', async ()=>{
    els.fsSupportHint.textContent = fsSupported() ? '' : 'FS API не поддерживается — будет локальный fallback.';
    openPresetsModal();
    await refreshPresetsList();
  });
  els.presetsCloseBtn.addEventListener('click', closePresetsModal);
  els.linkStylesBtn.addEventListener('click', linkStylesFile);
  els.presetRefreshBtn.addEventListener('click', refreshPresetsList);
  els.presetSaveBtn.addEventListener('click', onSavePreset);
  els.presetInsertBtn.addEventListener('click', onInsertSelectedPresets);
  els.presetSelectAll.addEventListener('click', ()=> selectAllPresets(true));
  els.presetSelectNone.addEventListener('click', ()=> selectAllPresets(false));
}

async function init(){
  // попытка восстановить доступ к D:\...\styles.json (через сохранённый handle)
  await restoreStylesHandle();
  await refreshPresetsList();

  // init translate toggle
  initTranslateBtn();

  // viewport / загрузчики / навигация / история
  calcViewportSize(); setupLoaders(); setupNav(); renderHistory();

  // ui
  setupCoreUI();

  // per-image visibility
  updatePerImageVisibility();

  // ar visibility
  updateArVisibility(); updateDropzoneVisibility();

  // initial render
  await redrawCurrent();

  // resize hooks
  window.addEventListener('resize', handleViewportChange);
  if(window.visualViewport){
    window.visualViewport.addEventListener('resize', handleViewportChange);
    window.visualViewport.addEventListener('scroll', handleViewportChange);
  }

  // initial prompt panel
  document.getElementById('promptPanel').classList.add('show');
}
init();

/* ===== helper: href->blob for downloads ===== */
async function ensureAnchorBlobHref(a, dataURL){
  try{
    if(!dataURL || dataURL.startsWith('blob:')) return;
    a.href = await getBlobUrl(dataURL);
  }catch{}
}

/* ===== Обычная отправка (кнопка «Отправить») ===== */
let sendDebounce = 0;
async function onSend(){
  const now = Date.now();
  if(now - sendDebounce < 400) return;
  sendDebounce = now;

  if(state.generating) return;
  const promptRU = (els.prompt.value||'').trim();
  const n = Math.min(Math.max(parseInt(els.varCount.value)||1,1),10);
  const perImage = state.perImage;

  if(!promptRU && state.inputs.length===0){ showToast('Добавь промт или загрузки', 2200); return; }

  let promptEN = promptRU;
  let perPromptsEN = [];
  if(state.translateEnabled){
    promptEN = await translateRuToEn(promptRU);
    if(promptEN) showToast(`EN: ${promptEN}`, 2600);
    if(perImage && state.inputs.length){ const ruList = state.inputs.map(x=> x.perPrompt || ''); perPromptsEN = await translateListRuToEn(ruList); }
  }else{
    if(state.inputs.length===0){
      const arText = els.arSelect.value || '1:1';
      if(promptEN) promptEN += `\nThe image should be in a ${arText} aspect ratio.`;
    }
  }
  if(state.translateEnabled && state.inputs.length===0){
    const arText = els.arSelect.value || '1:1';
    if(promptEN) promptEN += `\nThe image should be in a ${arText} aspect ratio.`;
  }

  state.outputs = []; state.currentIdx = 0; setShowResults(false);
  const ok = await generateParallelStaggered(n, promptEN, perImage, perPromptsEN);
  if(!ok){ showToast('Модель не вернула изображения. Уточни промт или добавь картинку.', 2600); return; }

  const item = {
    id: makeId(), time: Date.now(),
    promptRU, promptEN,
    perImagePrompts: state.inputs.map(x=> x.perPrompt || ''),
    srcList: state.inputs.map(x=> x.dataURL),
    srcMeta: state.inputs.map(x=> ({w:x.w,h:x.h,mime:x.mime,createdAt:x.createdAt})),
    outputs: state.outputs.map(o=>o.dataURL),
    currentIdx: state.currentIdx,
  };
  saveHistoryItem(item);
  showToast('Готово', 1100);
}
</script>
<script>
/*
 * cropper.js
 *
 * This module injects a cropping tool into the existing nano‑banana UI.
 * When the user has an active uploaded image, a new ✂︎ button appears in the
 * top‑left corner of the stage. Clicking the button opens a modal with a
 * canvas and adjustable selection rectangle. Users can drag the selection
 * area or its handles to choose the crop region, zoom in/out with the mouse
 * wheel, and choose to lock aspect ratio. Upon applying, the selected
 * portion replaces the current active input image in `state.inputs`, and
 * the UI updates accordingly. Cancelling closes the modal without changes.
 */

(() => {
  // Helper to wait until the global UI is ready (state and els defined)
  const waitForGlobals = () => new Promise(resolve => {
    const tick = () => {
      // Wait until script.js has defined state and els and we have an active grid
      if (typeof state !== 'undefined' && typeof els !== 'undefined') {
        resolve();
      } else {
        setTimeout(tick, 60);
      }
    };
    tick();
  });

  // Shortcuts for device pixel ratio and clamping
  const DPR = () => window.devicePixelRatio || 1;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // Internal cropping state
  const C = {
    img: null,        // ImageBitmap of the active input
    imgW: 0,
    imgH: 0,
    viewScale: 1,
    viewDx: 0,
    viewDy: 0,
    sel: { x: 0, y: 0, w: 0, h: 0 },
    dragging: false,
    dragKind: 'move',
    start: { x: 0, y: 0, sel: null },
    lockAR: false,
    ar: 'free',
  };

  // Utility to get cropping modal elements
  function getCropEls() {
    return {
      modal: document.getElementById('cropModal'),
      canvas: document.getElementById('cropCanvas'),
      overlay: document.getElementById('cropOverlay'),
      btnApply: document.getElementById('cropApply'),
      btnCancel: document.getElementById('cropCancel'),
      lockAR: document.getElementById('cropLockAR'),
      arSel: document.getElementById('cropAR'),
      handles: [...document.querySelectorAll('#cropModal .cr-h')],
    };
  }

  // Create or reuse the crop button in the top‑left panel
  function ensureCropButton() {
    const host = document.querySelector('.top-left');
    if (!host) return;
    if (document.getElementById('cropOpenBtn')) return;
    const btn = document.createElement('button');
    btn.id = 'cropOpenBtn';
    btn.textContent = '✂︎ Кадрировать';
    btn.title = 'Обрезать активное изображение';
    btn.addEventListener('click', openCropForActive);
    host.appendChild(btn);
    updateCropButtonState();
  }

  // Enable/disable crop button based on whether an active input is selected
  function updateCropButtonState() {
    const btn = document.getElementById('cropOpenBtn');
    if (!btn) return;
    const hasActive = !!state.activeId && state.inputs.some(x => x.id === state.activeId);
    btn.disabled = !hasActive || state.generating;
  }

  // Fit cropping canvas to its container
  function fitCropCanvas(cv) {
    const box = cv.parentElement.getBoundingClientRect();
    const dpr = DPR();
    cv.style.width = box.width + 'px';
    cv.style.height = box.height + 'px';
    cv.width = Math.max(2, Math.floor(box.width * dpr));
    cv.height = Math.max(2, Math.floor(box.height * dpr));
  }

  // Layout the image to fit the canvas and compute view scale and offsets
  function layoutImage(cv) {
    if (!C.img) return;
    const vw = cv.width;
    const vh = cv.height;
    const scale = Math.min(vw / C.imgW, vh / C.imgH);
    C.viewScale = scale;
    C.viewDx = Math.floor((vw - C.imgW * scale) / 2);
    C.viewDy = Math.floor((vh - C.imgH * scale) / 2);
  }

  // Draw the image onto the cropping canvas
  function drawScene(cv) {
    const ctx = cv.getContext('2d');
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.clearRect(0, 0, cv.width, cv.height);
    if (!C.img) return;
    const dw = Math.floor(C.imgW * C.viewScale);
    const dh = Math.floor(C.imgH * C.viewScale);
    ctx.drawImage(C.img, C.viewDx, C.viewDy, dw, dh);
  }

  // Update overlay position and handle positions
  function paintOverlay() {
    const { overlay } = getCropEls();
    const toCSS = px => `${px / DPR()}px`;
    const { x, y, w, h } = C.sel;
    overlay.style.left = toCSS(x);
    overlay.style.top = toCSS(y);
    overlay.style.width = toCSS(w);
    overlay.style.height = toCSS(h);
    const parentStyle = overlay.parentElement.style;
    parentStyle.setProperty('--x', toCSS(x));
    parentStyle.setProperty('--y', toCSS(y));
    parentStyle.setProperty('--x2', toCSS(x + w));
    parentStyle.setProperty('--y2', toCSS(y + h));
    parentStyle.setProperty('--xMid', toCSS(x + w / 2));
    parentStyle.setProperty('--yMid', toCSS(y + h / 2));
  }

  // Convert mouse event to canvas coordinates (device pixels)
  function canvasCoords(cv, e) {
    const r = cv.getBoundingClientRect();
    const x = (e.clientX - r.left) * DPR();
    const y = (e.clientY - r.top) * DPR();
    return { x, y };
  }

  // Rectangle of view area where image is drawn (in canvas px)
  function viewRect() {
    return {
      x: C.viewDx,
      y: C.viewDy,
      w: Math.floor(C.imgW * C.viewScale),
      h: Math.floor(C.imgH * C.viewScale),
    };
  }

  // Ensure selection stays within image bounds
  function clampSelection() {
    const vr = viewRect();
    C.sel.x = clamp(C.sel.x, vr.x, vr.x + vr.w - 2);
    C.sel.y = clamp(C.sel.y, vr.y, vr.y + vr.h - 2);
    C.sel.w = clamp(C.sel.w, 2, vr.w - (C.sel.x - vr.x));
    C.sel.h = clamp(C.sel.h, 2, vr.h - (C.sel.y - vr.y));
  }

  // Convert selection rectangle from canvas px to source image px
  function selectionToSourceRect() {
    const sx = (C.sel.x - C.viewDx) / C.viewScale;
    const sy = (C.sel.y - C.viewDy) / C.viewScale;
    const sw = C.sel.w / C.viewScale;
    const sh = C.sel.h / C.viewScale;
    const x = Math.max(0, Math.floor(sx));
    const y = Math.max(0, Math.floor(sy));
    const w = Math.max(1, Math.min(C.imgW - x, Math.floor(sw)));
    const h = Math.max(1, Math.min(C.imgH - y, Math.floor(sh)));
    return { x, y, w, h };
  }

  // Initialize selection rectangle with 70% of image area
  function initSelection() {
    const vr = viewRect();
    const w = Math.floor(vr.w * 0.7);
    const h = Math.floor(vr.h * 0.7);
    C.sel.w = w;
    C.sel.h = h;
    C.sel.x = Math.floor(vr.x + (vr.w - w) / 2);
    C.sel.y = Math.floor(vr.y + (vr.h - h) / 2);
    applyAspectIfLocked();
    clampSelection();
  }

  // Parse aspect ratio string (e.g. "4:5")
  function parseAR(str) {
    if (!str || str === 'free') return null;
    const [a, b] = str.split(':').map(v => Math.max(parseFloat(v) || 1, 1));
    return a / b;
  }

  // Apply aspect ratio if locked
  function applyAspectIfLocked(kind) {
    if (!C.lockAR) return;
    const targetAR = parseAR(C.ar) || (C.sel.w / C.sel.h);
    if (!Number.isFinite(targetAR)) return;
    const cx = C.sel.x + C.sel.w / 2;
    const cy = C.sel.y + C.sel.h / 2;
    let w = C.sel.w;
    let h = Math.round(w / targetAR);
    if (h > C.sel.h && kind && /n|s/.test(kind)) {
      h = C.sel.h;
      w = Math.round(h * targetAR);
    } else if (h > viewRect().h) {
      h = viewRect().h;
      w = Math.round(h * targetAR);
    }
    C.sel.w = w;
    C.sel.h = h;
    C.sel.x = Math.round(cx - w / 2);
    C.sel.y = Math.round(cy - h / 2);
  }

  // Bind mouse interactions for moving/resizing the selection
  function bindInteractions() {
    const { canvas, overlay, handles } = getCropEls();
    // Generic handler for mousedown / touchstart
    const startDrag = kind => e => {
      e.preventDefault();
      C.dragKind = kind || 'move';
      C.dragging = true;
      const p = canvasCoords(canvas, e.touches?.[0] || e);
      C.start.x = p.x;
      C.start.y = p.y;
      C.start.sel = { ...C.sel };
    };
    // Handler for mousemove / touchmove
    const onMove = e => {
      if (!C.dragging) return;
      const p = canvasCoords(canvas, e.touches?.[0] || e);
      const dx = p.x - C.start.x;
      const dy = p.y - C.start.y;
      const { x, y, w, h } = C.start.sel;
      const k = C.dragKind;
      if (k === 'move') {
        C.sel.x = x + dx;
        C.sel.y = y + dy;
      } else {
        let nx = x;
        let ny = y;
        let nw = w;
        let nh = h;
        if (k.includes('e')) nw = clamp(w + dx, 2, viewRect().w);
        if (k.includes('s')) nh = clamp(h + dy, 2, viewRect().h);
        if (k.includes('w')) { nx = x + dx; nw = clamp(w - dx, 2, viewRect().w); }
        if (k.includes('n')) { ny = y + dy; nh = clamp(h - dy, 2, viewRect().h); }
        C.sel.x = nx;
        C.sel.y = ny;
        C.sel.w = nw;
        C.sel.h = nh;
        if (C.lockAR) applyAspectIfLocked(k);
      }
      clampSelection();
      paintOverlay();
    };
    const endDrag = () => { C.dragging = false; };
    overlay.addEventListener('mousedown', startDrag('move'));
    overlay.addEventListener('touchstart', startDrag('move'), { passive: false });
    handles.forEach(h => {
      const dir = h.getAttribute('data-dir');
      h.addEventListener('mousedown', startDrag(dir));
      h.addEventListener('touchstart', startDrag(dir), { passive: false });
    });
    window.addEventListener('mousemove', onMove);
    window.addEventListener('touchmove', onMove, { passive: false });
    window.addEventListener('mouseup', endDrag);
    window.addEventListener('touchend', endDrag);
  }

  // Bind mouse wheel for zooming
  function bindZoom() {
    const { canvas } = getCropEls();
    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      const prev = C.viewScale;
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      const next = clamp(prev * delta, 0.1, 5);
      const p = canvasCoords(canvas, e);
      const imgX = (p.x - C.viewDx) / prev;
      const imgY = (p.y - C.viewDy) / prev;
      C.viewScale = next;
      const dw = Math.floor(C.imgW * next);
      const dh = Math.floor(C.imgH * next);
      C.viewDx = Math.floor(p.x - imgX * next);
      C.viewDy = Math.floor(p.y - imgY * next);
      const cvw = canvas.width;
      const cvh = canvas.height;
      C.viewDx = clamp(C.viewDx, cvw - dw, 0);
      C.viewDy = clamp(C.viewDy, cvh - dh, 0);
      drawScene(canvas);
      clampSelection();
      paintOverlay();
    }, { passive: false });
  }

  // Open the cropping modal for the current active image
  async function openCropForActive() {
    // Find the active input or fallback to the first input
    const item = state.inputs.find(x => x.id === state.activeId) || state.inputs[0];
    if (!item) {
      if (typeof toast === 'function') toast('Нет активного изображения');
      return;
    }
    const { modal, canvas, btnApply, btnCancel, lockAR, arSel } = getCropEls();
    // Load the image into an ImageBitmap
    const blob = item.blob || await (await fetch(item.dataURL)).blob();
    C.img = await createImageBitmap(blob);
    C.imgW = C.img.width;
    C.imgH = C.img.height;
    C.lockAR = !!lockAR.checked;
    C.ar = arSel.value || 'free';
    // Show modal
    modal.style.display = 'grid';
    // Fit canvas and draw image
    fitCropCanvas(canvas);
    layoutImage(canvas);
    drawScene(canvas);
    initSelection();
    paintOverlay();
    // Sync AR controls
    function onARChange() {
      C.ar = arSel.value || 'free';
      C.lockAR = lockAR.checked;
      applyAspectIfLocked();
      clampSelection();
      paintOverlay();
    }
    arSel.addEventListener('change', onARChange);
    lockAR.addEventListener('change', onARChange);
    // Keyboard shortcuts
    function onKey(e) {
      if (e.key === 'Escape') close(false);
      if (e.key === 'Enter') close(true);
    }
    document.addEventListener('keydown', onKey);
    // Cancel/apply buttons
    btnCancel.onclick = () => close(false);
    btnApply.onclick = () => close(true);
    async function close(apply) {
      // Clean up listeners
      document.removeEventListener('keydown', onKey);
      arSel.removeEventListener('change', onARChange);
      lockAR.removeEventListener('change', onARChange);
      modal.style.display = 'none';
      if (!apply) return;
      // Crop the selected region
      const src = selectionToSourceRect();
      const off = ('OffscreenCanvas' in window)
        ? new OffscreenCanvas(src.w, src.h)
        : Object.assign(document.createElement('canvas'), { width: src.w, height: src.h });
      if (!('width' in off)) {
        off.width = src.w;
        off.height = src.h;
      }
      const ctx = off.getContext('2d');
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(C.img, src.x, src.y, src.w, src.h, 0, 0, src.w, src.h);
      const outBlob = off.convertToBlob
        ? await off.convertToBlob({ type: 'image/png', quality: .98 })
        : await new Promise(res => off.toBlob(res, 'image/png', .98));
      // Convert back to data URL
      const outDataURL = await (async () => {
        if (window.blobToDataURL) return window.blobToDataURL(outBlob);
        return new Promise(res => {
          const fr = new FileReader();
          fr.onload = () => res(fr.result);
          fr.readAsDataURL(outBlob);
        });
      })();
      const bmp = await createImageBitmap(outBlob);
      // Update the item in state.inputs
      Object.assign(item, {
        dataURL: outDataURL,
        blob: outBlob,
        w: bmp.width,
        h: bmp.height,
        mime: outBlob.type || 'image/png',
        createdAt: Date.now(),
      });
      // Propagate updates to UI
      if (typeof renderInputGrid === 'function') renderInputGrid();
      if (typeof setActive === 'function') setActive(item.id);
      if (typeof calcViewportSize === 'function') calcViewportSize();
      if (typeof redrawCurrent === 'function') redrawCurrent();
      if (typeof toast === 'function') toast('Изображение обрезано');
    }
  }

  // Convert event coordinates into canvas device coordinates
  function canvasCoords(cv, e) {
    const rect = cv.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left) * DPR(),
      y: (e.clientY - rect.top) * DPR(),
    };
  }

  // Initialize the cropper once globals are ready
  async function init() {
    await waitForGlobals();
    ensureCropButton();
    bindInteractions();
    bindZoom();
    // Observe DOM mutations and update crop button state
    const mo = new MutationObserver(() => updateCropButtonState());
    mo.observe(document.body, { childList: true, subtree: true });
    // Periodic update as a fallback
    setInterval(updateCropButtonState, 500);
    // Resize event to redraw cropping view if modal open
    window.addEventListener('resize', () => {
      const { canvas, modal } = getCropEls();
      if (modal.style.display === 'grid') {
        fitCropCanvas(canvas);
        layoutImage(canvas);
        drawScene(canvas);
        clampSelection();
        paintOverlay();
      }
    });
  }
  init();
})();
</script>
</body>
</html>
